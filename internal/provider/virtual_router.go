package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/virtual_router"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &VirtualRouterDataSource{}
	_ datasource.DataSourceWithConfigure = &VirtualRouterDataSource{}
)

func NewVirtualRouterDataSource() datasource.DataSource {
	return &VirtualRouterDataSource{}
}

type VirtualRouterDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service]
}

type VirtualRouterDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}
type VirtualRouterDataSourceTfid struct {
	Name     string                  `json:"name"`
	Location virtual_router.Location `json:"location"`
}

func (o *VirtualRouterDataSourceTfid) IsValid() error {
	if o.Name == "" {
		return fmt.Errorf("name is unspecified")
	}
	return o.Location.IsValid()
}

type VirtualRouterDataSourceModel struct {
	Tfid                    types.String                                          `tfsdk:"tfid"`
	Location                VirtualRouterLocation                                 `tfsdk:"location"`
	Name                    types.String                                          `tfsdk:"name"`
	Interfaces              types.List                                            `tfsdk:"interfaces"`
	RoutingTable            *VirtualRouterDataSourceRoutingTableObject            `tfsdk:"routing_table"`
	Protocol                *VirtualRouterDataSourceProtocolObject                `tfsdk:"protocol"`
	Ecmp                    *VirtualRouterDataSourceEcmpObject                    `tfsdk:"ecmp"`
	AdministrativeDistances *VirtualRouterDataSourceAdministrativeDistancesObject `tfsdk:"administrative_distances"`
}
type VirtualRouterDataSourceRoutingTableObject struct {
	Ip   *VirtualRouterDataSourceRoutingTableIpObject   `tfsdk:"ip"`
	Ipv6 *VirtualRouterDataSourceRoutingTableIpv6Object `tfsdk:"ipv6"`
}
type VirtualRouterDataSourceRoutingTableIpObject struct {
	StaticRoutes types.List `tfsdk:"static_routes"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRoutesObject struct {
	Name        types.String                                                    `tfsdk:"name"`
	AdminDist   types.Int64                                                     `tfsdk:"admin_dist"`
	Metric      types.Int64                                                     `tfsdk:"metric"`
	RouteTable  types.String                                                    `tfsdk:"route_table"`
	Destination types.String                                                    `tfsdk:"destination"`
	Interface   types.String                                                    `tfsdk:"interface"`
	NextHop     *VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject `tfsdk:"next_hop"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject struct {
	NextVr    types.String `tfsdk:"next_vr"`
	Tunnel    types.String `tfsdk:"tunnel"`
	IpAddress types.String `tfsdk:"ip_address"`
	Fqdn      types.String `tfsdk:"fqdn"`
}
type VirtualRouterDataSourceRoutingTableIpv6Object struct {
	StaticRoutes types.List `tfsdk:"static_routes"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject struct {
	Name        types.String                                                      `tfsdk:"name"`
	Metric      types.Int64                                                       `tfsdk:"metric"`
	RouteTable  types.String                                                      `tfsdk:"route_table"`
	Destination types.String                                                      `tfsdk:"destination"`
	Interface   types.String                                                      `tfsdk:"interface"`
	NextHop     *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject `tfsdk:"next_hop"`
	AdminDist   types.Int64                                                       `tfsdk:"admin_dist"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject struct {
	Ipv6Address types.String `tfsdk:"ipv6_address"`
	Fqdn        types.String `tfsdk:"fqdn"`
	NextVr      types.String `tfsdk:"next_vr"`
	Tunnel      types.String `tfsdk:"tunnel"`
}
type VirtualRouterDataSourceProtocolObject struct {
	Ospf   *VirtualRouterDataSourceProtocolOspfObject   `tfsdk:"ospf"`
	Ospfv3 *VirtualRouterDataSourceProtocolOspfv3Object `tfsdk:"ospfv3"`
	Bgp    *VirtualRouterDataSourceProtocolBgpObject    `tfsdk:"bgp"`
	Rip    *VirtualRouterDataSourceProtocolRipObject    `tfsdk:"rip"`
}
type VirtualRouterDataSourceProtocolBgpObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolRipObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolOspfObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolOspfv3Object struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterDataSourceEcmpObject struct {
	Enable           types.Bool                                  `tfsdk:"enable"`
	SymmetricReturn  types.Bool                                  `tfsdk:"symmetric_return"`
	StrictSourcePath types.Bool                                  `tfsdk:"strict_source_path"`
	MaxPaths         types.Int64                                 `tfsdk:"max_paths"`
	Algorithm        *VirtualRouterDataSourceEcmpAlgorithmObject `tfsdk:"algorithm"`
}
type VirtualRouterDataSourceEcmpAlgorithmObject struct {
	IpModulo           *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject           `tfsdk:"ip_modulo"`
	IpHash             *VirtualRouterDataSourceEcmpAlgorithmIpHashObject             `tfsdk:"ip_hash"`
	WeightedRoundRobin *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject `tfsdk:"balanced_round_robin"`
}
type VirtualRouterDataSourceEcmpAlgorithmIpModuloObject struct {
}
type VirtualRouterDataSourceEcmpAlgorithmIpHashObject struct {
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
}
type VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject struct {
	Interfaces types.List `tfsdk:"interfaces"`
}
type VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject struct {
}
type VirtualRouterDataSourceAdministrativeDistancesObject struct {
	Static     types.Int64 `tfsdk:"static"`
	StaticIpv6 types.Int64 `tfsdk:"static_ipv6"`
	OspfInt    types.Int64 `tfsdk:"ospf_int"`
	Rip        types.Int64 `tfsdk:"rip"`
	OspfExt    types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Int  types.Int64 `tfsdk:"ospfv3_int"`
	Ospfv3Ext  types.Int64 `tfsdk:"ospfv3_ext"`
	Ibgp       types.Int64 `tfsdk:"ibgp"`
	Ebgp       types.Int64 `tfsdk:"ebgp"`
}

func (o *VirtualRouterDataSourceModel) CopyToPango(ctx context.Context, obj **virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var administrativeDistances_entry *virtual_router.AdministrativeDistances
	if o.AdministrativeDistances != nil {
		if *obj != nil && (*obj).AdministrativeDistances != nil {
			administrativeDistances_entry = (*obj).AdministrativeDistances
		} else {
			administrativeDistances_entry = new(virtual_router.AdministrativeDistances)
		}

		diags.Append(o.AdministrativeDistances.CopyToPango(ctx, &administrativeDistances_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaces_pango_entries := make([]string, 0)
	diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var routingTable_entry *virtual_router.RoutingTable
	if o.RoutingTable != nil {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(virtual_router.RoutingTable)
		}

		diags.Append(o.RoutingTable.CopyToPango(ctx, &routingTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *virtual_router.Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(virtual_router.Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *virtual_router.Ecmp
	if o.Ecmp != nil {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(virtual_router.Ecmp)
		}

		diags.Append(o.Ecmp.CopyToPango(ctx, &ecmp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AdministrativeDistances = administrativeDistances_entry
	(*obj).Interfaces = interfaces_pango_entries
	(*obj).RoutingTable = routingTable_entry
	(*obj).Protocol = protocol_entry
	(*obj).Ecmp = ecmp_entry

	return diags
}
func (o *VirtualRouterDataSourceEcmpObject) CopyToPango(ctx context.Context, obj **virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	var algorithm_entry *virtual_router.EcmpAlgorithm
	if o.Algorithm != nil {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(virtual_router.EcmpAlgorithm)
		}

		diags.Append(o.Algorithm.CopyToPango(ctx, &algorithm_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.Ecmp)
	}
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).MaxPaths = maxPaths_value
	(*obj).Algorithm = algorithm_entry
	(*obj).Enable = enable_value
	(*obj).SymmetricReturn = symmetricReturn_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_entry *virtual_router.EcmpAlgorithmIpModulo
	if o.IpModulo != nil {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(virtual_router.EcmpAlgorithmIpModulo)
		}

		diags.Append(o.IpModulo.CopyToPango(ctx, &ipModulo_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *virtual_router.EcmpAlgorithmIpHash
	if o.IpHash != nil {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(virtual_router.EcmpAlgorithmIpHash)
		}

		diags.Append(o.IpHash.CopyToPango(ctx, &ipHash_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *virtual_router.EcmpAlgorithmWeightedRoundRobin
	if o.WeightedRoundRobin != nil {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
		}

		diags.Append(o.WeightedRoundRobin.CopyToPango(ctx, &weightedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_entry *virtual_router.EcmpAlgorithmBalancedRoundRobin
	if o.BalancedRoundRobin != nil {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
		}

		diags.Append(o.BalancedRoundRobin.CopyToPango(ctx, &balancedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithm)
	}
	(*obj).IpModulo = ipModulo_entry
	(*obj).IpHash = ipHash_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpHash)
	}
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_tf_entries []VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject
	var interfaces_pango_entries []virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interfaces = interfaces_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *VirtualRouterDataSourceAdministrativeDistancesObject) CopyToPango(ctx context.Context, obj **virtual_router.AdministrativeDistances, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInt_value := o.OspfInt.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()
	ebgp_value := o.Ebgp.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Int_value := o.Ospfv3Int.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	ibgp_value := o.Ibgp.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.AdministrativeDistances)
	}
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInt = ospfInt_value
	(*obj).Rip = rip_value
	(*obj).Ebgp = ebgp_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Int = ospfv3Int_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).Ibgp = ibgp_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *virtual_router.RoutingTableIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(virtual_router.RoutingTableIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *virtual_router.RoutingTableIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(virtual_router.RoutingTableIpv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_tf_entries []VirtualRouterDataSourceRoutingTableIpStaticRoutesObject
	var staticRoutes_pango_entries []virtual_router.RoutingTableIpStaticRoutes
	{
		d := o.StaticRoutes.ElementsAs(ctx, &staticRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoutes_tf_entries {
			var entry *virtual_router.RoutingTableIpStaticRoutes
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoutes_pango_entries = append(staticRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIp)
	}
	(*obj).StaticRoutes = staticRoutes_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutesObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextHop_entry *virtual_router.RoutingTableIpStaticRoutesNextHop
	if o.NextHop != nil {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(virtual_router.RoutingTableIpStaticRoutesNextHop)
		}

		diags.Append(o.NextHop.CopyToPango(ctx, &nextHop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	adminDist_value := o.AdminDist.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	routeTable_value := o.RouteTable.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NextHop = nextHop_entry
	(*obj).AdminDist = adminDist_value
	(*obj).Metric = metric_value
	(*obj).RouteTable = routeTable_value
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextVr_value := o.NextVr.ValueStringPointer()
	tunnel_value := o.Tunnel.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutesNextHop)
	}
	(*obj).IpAddress = ipAddress_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextVr = nextVr_value
	(*obj).Tunnel = tunnel_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6Object) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_tf_entries []VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject
	var staticRoutes_pango_entries []virtual_router.RoutingTableIpv6StaticRoutes
	{
		d := o.StaticRoutes.ElementsAs(ctx, &staticRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoutes_tf_entries {
			var entry *virtual_router.RoutingTableIpv6StaticRoutes
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoutes_pango_entries = append(staticRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6)
	}
	(*obj).StaticRoutes = staticRoutes_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	routeTable_value := o.RouteTable.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	var nextHop_entry *virtual_router.RoutingTableIpv6StaticRoutesNextHop
	if o.NextHop != nil {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(virtual_router.RoutingTableIpv6StaticRoutesNextHop)
		}

		diags.Append(o.NextHop.CopyToPango(ctx, &nextHop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	adminDist_value := o.AdminDist.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value
	(*obj).RouteTable = routeTable_value
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).NextHop = nextHop_entry
	(*obj).AdminDist = adminDist_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextVr_value := o.NextVr.ValueStringPointer()
	tunnel_value := o.Tunnel.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutesNextHop)
	}
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextVr = nextVr_value
	(*obj).Tunnel = tunnel_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolObject) CopyToPango(ctx context.Context, obj **virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospf_entry *virtual_router.ProtocolOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolOspf)
		}

		diags.Append(o.Ospf.CopyToPango(ctx, &ospf_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *virtual_router.ProtocolOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolOspfv3)
		}

		diags.Append(o.Ospfv3.CopyToPango(ctx, &ospfv3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *virtual_router.ProtocolRip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(virtual_router.ProtocolRip)
		}

		diags.Append(o.Rip.CopyToPango(ctx, &rip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Protocol)
	}
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Bgp = bgp_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRip)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspf)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgp)
	}
	(*obj).Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceModel) CopyFromPango(ctx context.Context, obj *virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var list_diags diag.Diagnostics
		interfaces_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interfaces)
		diags.Append(list_diags...)
	}
	var ecmp_object *VirtualRouterDataSourceEcmpObject
	if obj.Ecmp != nil {
		ecmp_object = new(VirtualRouterDataSourceEcmpObject)

		diags.Append(ecmp_object.CopyFromPango(ctx, obj.Ecmp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_object *VirtualRouterDataSourceAdministrativeDistancesObject
	if obj.AdministrativeDistances != nil {
		administrativeDistances_object = new(VirtualRouterDataSourceAdministrativeDistancesObject)

		diags.Append(administrativeDistances_object.CopyFromPango(ctx, obj.AdministrativeDistances, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_object *VirtualRouterDataSourceRoutingTableObject
	if obj.RoutingTable != nil {
		routingTable_object = new(VirtualRouterDataSourceRoutingTableObject)

		diags.Append(routingTable_object.CopyFromPango(ctx, obj.RoutingTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_object *VirtualRouterDataSourceProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(VirtualRouterDataSourceProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Name = types.StringValue(obj.Name)
	o.Ecmp = ecmp_object
	o.AdministrativeDistances = administrativeDistances_object
	o.Interfaces = interfaces_list
	o.RoutingTable = routingTable_object
	o.Protocol = protocol_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolObject) CopyFromPango(ctx context.Context, obj *virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospf_object *VirtualRouterDataSourceProtocolOspfObject
	if obj.Ospf != nil {
		ospf_object = new(VirtualRouterDataSourceProtocolOspfObject)

		diags.Append(ospf_object.CopyFromPango(ctx, obj.Ospf, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *VirtualRouterDataSourceProtocolOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(VirtualRouterDataSourceProtocolOspfv3Object)

		diags.Append(ospfv3_object.CopyFromPango(ctx, obj.Ospfv3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterDataSourceProtocolBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterDataSourceProtocolBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_object *VirtualRouterDataSourceProtocolRipObject
	if obj.Rip != nil {
		rip_object = new(VirtualRouterDataSourceProtocolRipObject)

		diags.Append(rip_object.CopyFromPango(ctx, obj.Rip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Bgp = bgp_object
	o.Rip = rip_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpObject) CopyFromPango(ctx context.Context, obj *virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_object *VirtualRouterDataSourceEcmpAlgorithmObject
	if obj.Algorithm != nil {
		algorithm_object = new(VirtualRouterDataSourceEcmpAlgorithmObject)

		diags.Append(algorithm_object.CopyFromPango(ctx, obj.Algorithm, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	var maxPaths_value types.Int64
	if obj.MaxPaths != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPaths)
	}
	o.Enable = enable_value
	o.SymmetricReturn = symmetricReturn_value
	o.StrictSourcePath = strictSourcePath_value
	o.MaxPaths = maxPaths_value
	o.Algorithm = algorithm_object

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weightedRoundRobin_object *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject
	if obj.WeightedRoundRobin != nil {
		weightedRoundRobin_object = new(VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject)

		diags.Append(weightedRoundRobin_object.CopyFromPango(ctx, obj.WeightedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_object *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject
	if obj.BalancedRoundRobin != nil {
		balancedRoundRobin_object = new(VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject)

		diags.Append(balancedRoundRobin_object.CopyFromPango(ctx, obj.BalancedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_object *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject
	if obj.IpModulo != nil {
		ipModulo_object = new(VirtualRouterDataSourceEcmpAlgorithmIpModuloObject)

		diags.Append(ipModulo_object.CopyFromPango(ctx, obj.IpModulo, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_object *VirtualRouterDataSourceEcmpAlgorithmIpHashObject
	if obj.IpHash != nil {
		ipHash_object = new(VirtualRouterDataSourceEcmpAlgorithmIpHashObject)

		diags.Append(ipHash_object.CopyFromPango(ctx, obj.IpHash, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.WeightedRoundRobin = weightedRoundRobin_object
	o.BalancedRoundRobin = balancedRoundRobin_object
	o.IpModulo = ipModulo_object
	o.IpHash = ipHash_object

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value
	o.HashSeed = hashSeed_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject
		for _, elt := range obj.Interfaces {
			var entry VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interfaces_tf_entries = append(interfaces_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}
	o.Interfaces = interfaces_list

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceAdministrativeDistancesObject) CopyFromPango(ctx context.Context, obj *virtual_router.AdministrativeDistances, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var ibgp_value types.Int64
	if obj.Ibgp != nil {
		ibgp_value = types.Int64Value(*obj.Ibgp)
	}
	var ebgp_value types.Int64
	if obj.Ebgp != nil {
		ebgp_value = types.Int64Value(*obj.Ebgp)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Int_value types.Int64
	if obj.Ospfv3Int != nil {
		ospfv3Int_value = types.Int64Value(*obj.Ospfv3Int)
	}
	var ospfInt_value types.Int64
	if obj.OspfInt != nil {
		ospfInt_value = types.Int64Value(*obj.OspfInt)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	o.Ospfv3Ext = ospfv3Ext_value
	o.Ibgp = ibgp_value
	o.Ebgp = ebgp_value
	o.OspfExt = ospfExt_value
	o.Ospfv3Int = ospfv3Int_value
	o.OspfInt = ospfInt_value
	o.Rip = rip_value
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *VirtualRouterDataSourceRoutingTableIpObject
	if obj.Ip != nil {
		ip_object = new(VirtualRouterDataSourceRoutingTableIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *VirtualRouterDataSourceRoutingTableIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(VirtualRouterDataSourceRoutingTableIpv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6Object) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_list types.List
	{
		var staticRoutes_tf_entries []VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject
		for _, elt := range obj.StaticRoutes {
			var entry VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoutes_tf_entries = append(staticRoutes_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_routes")
		staticRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoutes_tf_entries)
		diags.Append(list_diags...)
	}
	o.StaticRoutes = staticRoutes_list

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextHop_object *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject
	if obj.NextHop != nil {
		nextHop_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject)

		diags.Append(nextHop_object.CopyFromPango(ctx, obj.NextHop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var adminDist_value types.Int64
	if obj.AdminDist != nil {
		adminDist_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.RouteTable = routeTable_value
	o.Destination = destination_value
	o.Interface = interface_value
	o.NextHop = nextHop_object
	o.AdminDist = adminDist_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	var tunnel_value types.String
	if obj.Tunnel != nil {
		tunnel_value = types.StringValue(*obj.Tunnel)
	}
	o.Ipv6Address = ipv6Address_value
	o.Fqdn = fqdn_value
	o.NextVr = nextVr_value
	o.Tunnel = tunnel_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_list types.List
	{
		var staticRoutes_tf_entries []VirtualRouterDataSourceRoutingTableIpStaticRoutesObject
		for _, elt := range obj.StaticRoutes {
			var entry VirtualRouterDataSourceRoutingTableIpStaticRoutesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoutes_tf_entries = append(staticRoutes_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_routes")
		staticRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoutes_tf_entries)
		diags.Append(list_diags...)
	}
	o.StaticRoutes = staticRoutes_list

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutesObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextHop_object *VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject
	if obj.NextHop != nil {
		nextHop_object = new(VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject)

		diags.Append(nextHop_object.CopyFromPango(ctx, obj.NextHop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var adminDist_value types.Int64
	if obj.AdminDist != nil {
		adminDist_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Name = types.StringValue(obj.Name)
	o.NextHop = nextHop_object
	o.AdminDist = adminDist_value
	o.Metric = metric_value
	o.RouteTable = routeTable_value
	o.Destination = destination_value
	o.Interface = interface_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	var tunnel_value types.String
	if obj.Tunnel != nil {
		tunnel_value = types.StringValue(*obj.Tunnel)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.NextVr = nextVr_value
	o.Tunnel = tunnel_value
	o.IpAddress = ipAddress_value
	o.Fqdn = fqdn_value

	return diags
}

func VirtualRouterDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": VirtualRouterDataSourceLocationSchema(),

			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				Required:    false,
				Optional:    false,
				Sensitive:   false,
			},

			"name": dsschema.StringAttribute{
				Description: "The name of the virtual router.",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ecmp": VirtualRouterDataSourceEcmpSchema(),

			"administrative_distances": VirtualRouterDataSourceAdministrativeDistancesSchema(),

			"interfaces": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"routing_table": VirtualRouterDataSourceRoutingTableSchema(),

			"protocol": VirtualRouterDataSourceProtocolSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceModel) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"symmetric_return": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"algorithm": VirtualRouterDataSourceEcmpAlgorithmSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"balanced_round_robin": VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema(),

			"ip_modulo": VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema(),

			"ip_hash": VirtualRouterDataSourceEcmpAlgorithmIpHashSchema(),

			"weighted_round_robin": VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmIpHashSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"src_only": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hash_seed": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interfaces": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceAdministrativeDistancesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ipv6": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_int": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rip": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_ext": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_int": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_ext": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ibgp": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ebgp": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": VirtualRouterDataSourceRoutingTableIpSchema(),

			"ipv6": VirtualRouterDataSourceRoutingTableIpv6Schema(),
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_routes": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceRoutingTableIpStaticRoutesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRoutesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopSchema(),

			"admin_dist": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"route_table": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRoutesNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_routes": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceRoutingTableIpv6StaticRoutesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRoutesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopSchema(),

			"admin_dist": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"route_table": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"tunnel": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRoutesNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ospf": VirtualRouterDataSourceProtocolOspfSchema(),

			"ospfv3": VirtualRouterDataSourceProtocolOspfv3Schema(),

			"bgp": VirtualRouterDataSourceProtocolBgpSchema(),

			"rip": VirtualRouterDataSourceProtocolRipSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceLocationSchema() rsschema.Attribute {
	return VirtualRouterLocationSchema()
}

// Metadata returns the data source type name.
func (d *VirtualRouterDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_virtual_router"
}

// Schema defines the schema for this data source.
func (d *VirtualRouterDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = VirtualRouterDataSourceSchema()
}

// Configure prepares the struct.
func (d *VirtualRouterDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := virtual_router.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, virtual_router.NewService(d.client), specifier, virtual_router.SpecMatches)
}

func (o *VirtualRouterDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state VirtualRouterDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var loc VirtualRouterDataSourceTfid
	loc.Name = *savestate.Name.ValueStringPointer()

	if savestate.Location.Template != nil {
		loc.Location.Template = &virtual_router.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		loc.Location.TemplateStack = &virtual_router.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Ngfw != nil {
		loc.Location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Read",
		"name":          loc.Name,
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, loc.Location, loc.Name)
	if err != nil {
		tflog.Warn(ctx, "KK: HERE3-1", map[string]any{"Error": err.Error()})
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location
	// Save tfid to state.
	state.Tfid = savestate.Tfid

	// Save the answer to state.

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &VirtualRouterResource{}
	_ resource.ResourceWithConfigure   = &VirtualRouterResource{}
	_ resource.ResourceWithImportState = &VirtualRouterResource{}
)

func NewVirtualRouterResource() resource.Resource {
	return &VirtualRouterResource{}
}

type VirtualRouterResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service]
}
type VirtualRouterResourceTfid struct {
	Name     string                  `json:"name"`
	Location virtual_router.Location `json:"location"`
}

func (o *VirtualRouterResourceTfid) IsValid() error {
	if o.Name == "" {
		return fmt.Errorf("name is unspecified")
	}
	return o.Location.IsValid()
}

func VirtualRouterResourceLocationSchema() rsschema.Attribute {
	return VirtualRouterLocationSchema()
}

type VirtualRouterResourceModel struct {
	Tfid                    types.String                                        `tfsdk:"tfid"`
	Location                VirtualRouterLocation                               `tfsdk:"location"`
	Name                    types.String                                        `tfsdk:"name"`
	Interfaces              types.List                                          `tfsdk:"interfaces"`
	RoutingTable            *VirtualRouterResourceRoutingTableObject            `tfsdk:"routing_table"`
	Protocol                *VirtualRouterResourceProtocolObject                `tfsdk:"protocol"`
	Ecmp                    *VirtualRouterResourceEcmpObject                    `tfsdk:"ecmp"`
	AdministrativeDistances *VirtualRouterResourceAdministrativeDistancesObject `tfsdk:"administrative_distances"`
}
type VirtualRouterResourceRoutingTableObject struct {
	Ip   *VirtualRouterResourceRoutingTableIpObject   `tfsdk:"ip"`
	Ipv6 *VirtualRouterResourceRoutingTableIpv6Object `tfsdk:"ipv6"`
}
type VirtualRouterResourceRoutingTableIpObject struct {
	StaticRoutes types.List `tfsdk:"static_routes"`
}
type VirtualRouterResourceRoutingTableIpStaticRoutesObject struct {
	Name        types.String                                                  `tfsdk:"name"`
	Metric      types.Int64                                                   `tfsdk:"metric"`
	RouteTable  types.String                                                  `tfsdk:"route_table"`
	Destination types.String                                                  `tfsdk:"destination"`
	Interface   types.String                                                  `tfsdk:"interface"`
	NextHop     *VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject `tfsdk:"next_hop"`
	AdminDist   types.Int64                                                   `tfsdk:"admin_dist"`
}
type VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Fqdn      types.String `tfsdk:"fqdn"`
	NextVr    types.String `tfsdk:"next_vr"`
	Tunnel    types.String `tfsdk:"tunnel"`
}
type VirtualRouterResourceRoutingTableIpv6Object struct {
	StaticRoutes types.List `tfsdk:"static_routes"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRoutesObject struct {
	Name        types.String                                                    `tfsdk:"name"`
	Destination types.String                                                    `tfsdk:"destination"`
	Interface   types.String                                                    `tfsdk:"interface"`
	NextHop     *VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject `tfsdk:"next_hop"`
	AdminDist   types.Int64                                                     `tfsdk:"admin_dist"`
	Metric      types.Int64                                                     `tfsdk:"metric"`
	RouteTable  types.String                                                    `tfsdk:"route_table"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject struct {
	Ipv6Address types.String `tfsdk:"ipv6_address"`
	Fqdn        types.String `tfsdk:"fqdn"`
	NextVr      types.String `tfsdk:"next_vr"`
	Tunnel      types.String `tfsdk:"tunnel"`
}
type VirtualRouterResourceProtocolObject struct {
	Rip    *VirtualRouterResourceProtocolRipObject    `tfsdk:"rip"`
	Ospf   *VirtualRouterResourceProtocolOspfObject   `tfsdk:"ospf"`
	Ospfv3 *VirtualRouterResourceProtocolOspfv3Object `tfsdk:"ospfv3"`
	Bgp    *VirtualRouterResourceProtocolBgpObject    `tfsdk:"bgp"`
}
type VirtualRouterResourceProtocolBgpObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterResourceProtocolRipObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterResourceProtocolOspfObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterResourceProtocolOspfv3Object struct {
	Enable types.Bool `tfsdk:"enable"`
}
type VirtualRouterResourceEcmpObject struct {
	Enable           types.Bool                                `tfsdk:"enable"`
	SymmetricReturn  types.Bool                                `tfsdk:"symmetric_return"`
	StrictSourcePath types.Bool                                `tfsdk:"strict_source_path"`
	MaxPaths         types.Int64                               `tfsdk:"max_paths"`
	Algorithm        *VirtualRouterResourceEcmpAlgorithmObject `tfsdk:"algorithm"`
}
type VirtualRouterResourceEcmpAlgorithmObject struct {
	IpModulo           *VirtualRouterResourceEcmpAlgorithmIpModuloObject           `tfsdk:"ip_modulo"`
	IpHash             *VirtualRouterResourceEcmpAlgorithmIpHashObject             `tfsdk:"ip_hash"`
	WeightedRoundRobin *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject `tfsdk:"balanced_round_robin"`
}
type VirtualRouterResourceEcmpAlgorithmIpModuloObject struct {
}
type VirtualRouterResourceEcmpAlgorithmIpHashObject struct {
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
}
type VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject struct {
	Interfaces types.List `tfsdk:"interfaces"`
}
type VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject struct {
}
type VirtualRouterResourceAdministrativeDistancesObject struct {
	Static     types.Int64 `tfsdk:"static"`
	StaticIpv6 types.Int64 `tfsdk:"static_ipv6"`
	OspfInt    types.Int64 `tfsdk:"ospf_int"`
	Rip        types.Int64 `tfsdk:"rip"`
	OspfExt    types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Int  types.Int64 `tfsdk:"ospfv3_int"`
	Ospfv3Ext  types.Int64 `tfsdk:"ospfv3_ext"`
	Ibgp       types.Int64 `tfsdk:"ibgp"`
	Ebgp       types.Int64 `tfsdk:"ebgp"`
}

func (r *VirtualRouterResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_virtual_router"
}

func (r *VirtualRouterResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func VirtualRouterResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": VirtualRouterResourceLocationSchema(),

			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				Required:    false,
				Optional:    false,
				Sensitive:   false,
			},

			"name": rsschema.StringAttribute{
				Description: "The name of the virtual router.",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"routing_table": VirtualRouterResourceRoutingTableSchema(),

			"protocol": VirtualRouterResourceProtocolSchema(),

			"ecmp": VirtualRouterResourceEcmpSchema(),

			"administrative_distances": VirtualRouterResourceAdministrativeDistancesSchema(),

			"interfaces": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceModel) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": VirtualRouterResourceRoutingTableIpSchema(),

			"ipv6": VirtualRouterResourceRoutingTableIpv6Schema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_routes": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceRoutingTableIpStaticRoutesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRoutesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"route_table": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": VirtualRouterResourceRoutingTableIpStaticRoutesNextHopSchema(),

			"admin_dist": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRoutesNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRoutesNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_routes": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceRoutingTableIpv6StaticRoutesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRoutesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopSchema(),

			"admin_dist": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"route_table": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv6_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"bgp": VirtualRouterResourceProtocolBgpSchema(),

			"rip": VirtualRouterResourceProtocolRipSchema(),

			"ospf": VirtualRouterResourceProtocolOspfSchema(),

			"ospfv3": VirtualRouterResourceProtocolOspfv3Schema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"algorithm": VirtualRouterResourceEcmpAlgorithmSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"weighted_round_robin": VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema(),

			"balanced_round_robin": VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema(),

			"ip_modulo": VirtualRouterResourceEcmpAlgorithmIpModuloSchema(),

			"ip_hash": VirtualRouterResourceEcmpAlgorithmIpHashSchema(),
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmIpHashSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"src_only": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hash_seed": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interfaces": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmIpModuloSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceAdministrativeDistancesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ipv6": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_int": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rip": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_ext": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_int": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_ext": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ibgp": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ebgp": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *VirtualRouterResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = VirtualRouterResourceSchema()
}

// </ResourceSchema>

func (r *VirtualRouterResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := virtual_router.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, virtual_router.NewService(r.client), specifier, virtual_router.SpecMatches)
}

func (o *VirtualRouterResourceModel) CopyToPango(ctx context.Context, obj **virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var routingTable_entry *virtual_router.RoutingTable
	if o.RoutingTable != nil {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(virtual_router.RoutingTable)
		}

		diags.Append(o.RoutingTable.CopyToPango(ctx, &routingTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *virtual_router.Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(virtual_router.Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *virtual_router.Ecmp
	if o.Ecmp != nil {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(virtual_router.Ecmp)
		}

		diags.Append(o.Ecmp.CopyToPango(ctx, &ecmp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_entry *virtual_router.AdministrativeDistances
	if o.AdministrativeDistances != nil {
		if *obj != nil && (*obj).AdministrativeDistances != nil {
			administrativeDistances_entry = (*obj).AdministrativeDistances
		} else {
			administrativeDistances_entry = new(virtual_router.AdministrativeDistances)
		}

		diags.Append(o.AdministrativeDistances.CopyToPango(ctx, &administrativeDistances_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaces_pango_entries := make([]string, 0)
	diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).RoutingTable = routingTable_entry
	(*obj).Protocol = protocol_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).AdministrativeDistances = administrativeDistances_entry
	(*obj).Interfaces = interfaces_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *virtual_router.RoutingTableIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(virtual_router.RoutingTableIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *virtual_router.RoutingTableIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(virtual_router.RoutingTableIpv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_tf_entries []VirtualRouterResourceRoutingTableIpStaticRoutesObject
	var staticRoutes_pango_entries []virtual_router.RoutingTableIpStaticRoutes
	{
		d := o.StaticRoutes.ElementsAs(ctx, &staticRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoutes_tf_entries {
			var entry *virtual_router.RoutingTableIpStaticRoutes
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoutes_pango_entries = append(staticRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIp)
	}
	(*obj).StaticRoutes = staticRoutes_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRoutesObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextHop_entry *virtual_router.RoutingTableIpStaticRoutesNextHop
	if o.NextHop != nil {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(virtual_router.RoutingTableIpStaticRoutesNextHop)
		}

		diags.Append(o.NextHop.CopyToPango(ctx, &nextHop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	adminDist_value := o.AdminDist.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	routeTable_value := o.RouteTable.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NextHop = nextHop_entry
	(*obj).AdminDist = adminDist_value
	(*obj).Metric = metric_value
	(*obj).RouteTable = routeTable_value
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	tunnel_value := o.Tunnel.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextVr_value := o.NextVr.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutesNextHop)
	}
	(*obj).Tunnel = tunnel_value
	(*obj).IpAddress = ipAddress_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextVr = nextVr_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6Object) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_tf_entries []VirtualRouterResourceRoutingTableIpv6StaticRoutesObject
	var staticRoutes_pango_entries []virtual_router.RoutingTableIpv6StaticRoutes
	{
		d := o.StaticRoutes.ElementsAs(ctx, &staticRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoutes_tf_entries {
			var entry *virtual_router.RoutingTableIpv6StaticRoutes
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoutes_pango_entries = append(staticRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6)
	}
	(*obj).StaticRoutes = staticRoutes_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutesObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	var nextHop_entry *virtual_router.RoutingTableIpv6StaticRoutesNextHop
	if o.NextHop != nil {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(virtual_router.RoutingTableIpv6StaticRoutesNextHop)
		}

		diags.Append(o.NextHop.CopyToPango(ctx, &nextHop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	adminDist_value := o.AdminDist.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	routeTable_value := o.RouteTable.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).NextHop = nextHop_entry
	(*obj).AdminDist = adminDist_value
	(*obj).Metric = metric_value
	(*obj).RouteTable = routeTable_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextVr_value := o.NextVr.ValueStringPointer()
	tunnel_value := o.Tunnel.ValueStringPointer()
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutesNextHop)
	}
	(*obj).Fqdn = fqdn_value
	(*obj).NextVr = nextVr_value
	(*obj).Tunnel = tunnel_value
	(*obj).Ipv6Address = ipv6Address_value

	return diags
}
func (o *VirtualRouterResourceProtocolObject) CopyToPango(ctx context.Context, obj **virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *virtual_router.ProtocolBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *virtual_router.ProtocolRip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(virtual_router.ProtocolRip)
		}

		diags.Append(o.Rip.CopyToPango(ctx, &rip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *virtual_router.ProtocolOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolOspf)
		}

		diags.Append(o.Ospf.CopyToPango(ctx, &ospf_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *virtual_router.ProtocolOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolOspfv3)
		}

		diags.Append(o.Ospfv3.CopyToPango(ctx, &ospfv3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Protocol)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Rip = rip_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgp)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRip)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspf)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceEcmpObject) CopyToPango(ctx context.Context, obj **virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	var algorithm_entry *virtual_router.EcmpAlgorithm
	if o.Algorithm != nil {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(virtual_router.EcmpAlgorithm)
		}

		diags.Append(o.Algorithm.CopyToPango(ctx, &algorithm_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.Ecmp)
	}
	(*obj).SymmetricReturn = symmetricReturn_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).MaxPaths = maxPaths_value
	(*obj).Algorithm = algorithm_entry
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_entry *virtual_router.EcmpAlgorithmIpModulo
	if o.IpModulo != nil {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(virtual_router.EcmpAlgorithmIpModulo)
		}

		diags.Append(o.IpModulo.CopyToPango(ctx, &ipModulo_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *virtual_router.EcmpAlgorithmIpHash
	if o.IpHash != nil {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(virtual_router.EcmpAlgorithmIpHash)
		}

		diags.Append(o.IpHash.CopyToPango(ctx, &ipHash_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *virtual_router.EcmpAlgorithmWeightedRoundRobin
	if o.WeightedRoundRobin != nil {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
		}

		diags.Append(o.WeightedRoundRobin.CopyToPango(ctx, &weightedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_entry *virtual_router.EcmpAlgorithmBalancedRoundRobin
	if o.BalancedRoundRobin != nil {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
		}

		diags.Append(o.BalancedRoundRobin.CopyToPango(ctx, &balancedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithm)
	}
	(*obj).IpModulo = ipModulo_entry
	(*obj).IpHash = ipHash_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpHash)
	}
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_tf_entries []VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject
	var interfaces_pango_entries []virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interfaces = interfaces_pango_entries

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *VirtualRouterResourceAdministrativeDistancesObject) CopyToPango(ctx context.Context, obj **virtual_router.AdministrativeDistances, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	rip_value := o.Rip.ValueInt64Pointer()
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInt_value := o.OspfInt.ValueInt64Pointer()
	ibgp_value := o.Ibgp.ValueInt64Pointer()
	ebgp_value := o.Ebgp.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Int_value := o.Ospfv3Int.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.AdministrativeDistances)
	}
	(*obj).Rip = rip_value
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInt = ospfInt_value
	(*obj).Ibgp = ibgp_value
	(*obj).Ebgp = ebgp_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Int = ospfv3Int_value
	(*obj).Ospfv3Ext = ospfv3Ext_value

	return diags
}

func (o *VirtualRouterResourceModel) CopyFromPango(ctx context.Context, obj *virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var list_diags diag.Diagnostics
		interfaces_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interfaces)
		diags.Append(list_diags...)
	}
	var protocol_object *VirtualRouterResourceProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(VirtualRouterResourceProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_object *VirtualRouterResourceEcmpObject
	if obj.Ecmp != nil {
		ecmp_object = new(VirtualRouterResourceEcmpObject)

		diags.Append(ecmp_object.CopyFromPango(ctx, obj.Ecmp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_object *VirtualRouterResourceAdministrativeDistancesObject
	if obj.AdministrativeDistances != nil {
		administrativeDistances_object = new(VirtualRouterResourceAdministrativeDistancesObject)

		diags.Append(administrativeDistances_object.CopyFromPango(ctx, obj.AdministrativeDistances, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_object *VirtualRouterResourceRoutingTableObject
	if obj.RoutingTable != nil {
		routingTable_object = new(VirtualRouterResourceRoutingTableObject)

		diags.Append(routingTable_object.CopyFromPango(ctx, obj.RoutingTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Name = types.StringValue(obj.Name)
	o.Protocol = protocol_object
	o.Ecmp = ecmp_object
	o.AdministrativeDistances = administrativeDistances_object
	o.Interfaces = interfaces_list
	o.RoutingTable = routingTable_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *VirtualRouterResourceRoutingTableIpObject
	if obj.Ip != nil {
		ip_object = new(VirtualRouterResourceRoutingTableIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *VirtualRouterResourceRoutingTableIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(VirtualRouterResourceRoutingTableIpv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_list types.List
	{
		var staticRoutes_tf_entries []VirtualRouterResourceRoutingTableIpStaticRoutesObject
		for _, elt := range obj.StaticRoutes {
			var entry VirtualRouterResourceRoutingTableIpStaticRoutesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoutes_tf_entries = append(staticRoutes_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_routes")
		staticRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoutes_tf_entries)
		diags.Append(list_diags...)
	}
	o.StaticRoutes = staticRoutes_list

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutesObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextHop_object *VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject
	if obj.NextHop != nil {
		nextHop_object = new(VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject)

		diags.Append(nextHop_object.CopyFromPango(ctx, obj.NextHop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var adminDist_value types.Int64
	if obj.AdminDist != nil {
		adminDist_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value
	o.NextHop = nextHop_object
	o.AdminDist = adminDist_value
	o.Metric = metric_value
	o.RouteTable = routeTable_value
	o.Destination = destination_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutesNextHopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tunnel_value types.String
	if obj.Tunnel != nil {
		tunnel_value = types.StringValue(*obj.Tunnel)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	o.Tunnel = tunnel_value
	o.IpAddress = ipAddress_value
	o.Fqdn = fqdn_value
	o.NextVr = nextVr_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6Object) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoutes_list types.List
	{
		var staticRoutes_tf_entries []VirtualRouterResourceRoutingTableIpv6StaticRoutesObject
		for _, elt := range obj.StaticRoutes {
			var entry VirtualRouterResourceRoutingTableIpv6StaticRoutesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoutes_tf_entries = append(staticRoutes_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_routes")
		staticRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoutes_tf_entries)
		diags.Append(list_diags...)
	}
	o.StaticRoutes = staticRoutes_list

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutesObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nextHop_object *VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject
	if obj.NextHop != nil {
		nextHop_object = new(VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject)

		diags.Append(nextHop_object.CopyFromPango(ctx, obj.NextHop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var adminDist_value types.Int64
	if obj.AdminDist != nil {
		adminDist_value = types.Int64Value(*obj.AdminDist)
	}
	o.Name = types.StringValue(obj.Name)
	o.Metric = metric_value
	o.RouteTable = routeTable_value
	o.Destination = destination_value
	o.Interface = interface_value
	o.NextHop = nextHop_object
	o.AdminDist = adminDist_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutesNextHopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutesNextHop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	var tunnel_value types.String
	if obj.Tunnel != nil {
		tunnel_value = types.StringValue(*obj.Tunnel)
	}
	o.Ipv6Address = ipv6Address_value
	o.Fqdn = fqdn_value
	o.NextVr = nextVr_value
	o.Tunnel = tunnel_value

	return diags
}

func (o *VirtualRouterResourceProtocolObject) CopyFromPango(ctx context.Context, obj *virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospf_object *VirtualRouterResourceProtocolOspfObject
	if obj.Ospf != nil {
		ospf_object = new(VirtualRouterResourceProtocolOspfObject)

		diags.Append(ospf_object.CopyFromPango(ctx, obj.Ospf, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *VirtualRouterResourceProtocolOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(VirtualRouterResourceProtocolOspfv3Object)

		diags.Append(ospfv3_object.CopyFromPango(ctx, obj.Ospfv3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterResourceProtocolBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterResourceProtocolBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_object *VirtualRouterResourceProtocolRipObject
	if obj.Rip != nil {
		rip_object = new(VirtualRouterResourceProtocolRipObject)

		diags.Append(rip_object.CopyFromPango(ctx, obj.Rip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Bgp = bgp_object
	o.Rip = rip_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceEcmpObject) CopyFromPango(ctx context.Context, obj *virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_object *VirtualRouterResourceEcmpAlgorithmObject
	if obj.Algorithm != nil {
		algorithm_object = new(VirtualRouterResourceEcmpAlgorithmObject)

		diags.Append(algorithm_object.CopyFromPango(ctx, obj.Algorithm, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	var maxPaths_value types.Int64
	if obj.MaxPaths != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPaths)
	}
	o.Algorithm = algorithm_object
	o.Enable = enable_value
	o.SymmetricReturn = symmetricReturn_value
	o.StrictSourcePath = strictSourcePath_value
	o.MaxPaths = maxPaths_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_object *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject
	if obj.BalancedRoundRobin != nil {
		balancedRoundRobin_object = new(VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject)

		diags.Append(balancedRoundRobin_object.CopyFromPango(ctx, obj.BalancedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_object *VirtualRouterResourceEcmpAlgorithmIpModuloObject
	if obj.IpModulo != nil {
		ipModulo_object = new(VirtualRouterResourceEcmpAlgorithmIpModuloObject)

		diags.Append(ipModulo_object.CopyFromPango(ctx, obj.IpModulo, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_object *VirtualRouterResourceEcmpAlgorithmIpHashObject
	if obj.IpHash != nil {
		ipHash_object = new(VirtualRouterResourceEcmpAlgorithmIpHashObject)

		diags.Append(ipHash_object.CopyFromPango(ctx, obj.IpHash, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_object *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject
	if obj.WeightedRoundRobin != nil {
		weightedRoundRobin_object = new(VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject)

		diags.Append(weightedRoundRobin_object.CopyFromPango(ctx, obj.WeightedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.BalancedRoundRobin = balancedRoundRobin_object
	o.IpModulo = ipModulo_object
	o.IpHash = ipHash_object
	o.WeightedRoundRobin = weightedRoundRobin_object

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value
	o.HashSeed = hashSeed_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject
		for _, elt := range obj.Interfaces {
			var entry VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interfaces_tf_entries = append(interfaces_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}
	o.Interfaces = interfaces_list

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfacesObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobinInterfaces, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceAdministrativeDistancesObject) CopyFromPango(ctx context.Context, obj *virtual_router.AdministrativeDistances, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Int_value types.Int64
	if obj.Ospfv3Int != nil {
		ospfv3Int_value = types.Int64Value(*obj.Ospfv3Int)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var ibgp_value types.Int64
	if obj.Ibgp != nil {
		ibgp_value = types.Int64Value(*obj.Ibgp)
	}
	var ebgp_value types.Int64
	if obj.Ebgp != nil {
		ebgp_value = types.Int64Value(*obj.Ebgp)
	}
	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	var ospfInt_value types.Int64
	if obj.OspfInt != nil {
		ospfInt_value = types.Int64Value(*obj.OspfInt)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	o.OspfExt = ospfExt_value
	o.Ospfv3Int = ospfv3Int_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.Ibgp = ibgp_value
	o.Ebgp = ebgp_value
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value
	o.OspfInt = ospfInt_value
	o.Rip = rip_value

	return diags
}

func (r *VirtualRouterResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.
	loc := VirtualRouterResourceTfid{Name: state.Name.ValueString()}

	// TODO: this needs to handle location structure for UUID style shared has nested structure type

	if state.Location.Ngfw != nil {
		loc.Location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		loc.Location.Template = &virtual_router.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		loc.Location.TemplateStack = &virtual_router.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	if err := loc.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *virtual_router.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, loc.Location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	// Tfid handling.
	tfid, err := EncodeLocation(&loc)
	if err != nil {
		resp.Diagnostics.AddError("Error creating tfid", err.Error())
		return
	}

	// Save the state.
	state.Tfid = types.StringValue(tfid)

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (o *VirtualRouterResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var loc VirtualRouterResourceTfid
	// Parse the location from tfid.
	if err := DecodeLocation(savestate.Tfid.ValueString(), &loc); err != nil {
		resp.Diagnostics.AddError("Error parsing tfid", err.Error())
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Read",
		"name":          loc.Name,
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, loc.Location, loc.Name)
	if err != nil {
		tflog.Warn(ctx, "KK: HERE3-1", map[string]any{"Error": err.Error()})
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location
	// Save tfid to state.
	state.Tfid = savestate.Tfid

	// Save the answer to state.

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *VirtualRouterResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var loc VirtualRouterResourceTfid
	if err := DecodeLocation(state.Tfid.ValueString(), &loc); err != nil {
		resp.Diagnostics.AddError("Error parsing tfid", err.Error())
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Update",
		"tfid":          state.Tfid.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, loc.Location, loc.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, loc.Location, obj, loc.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	// Save the tfid.
	loc.Name = obj.Name
	tfid, err := EncodeLocation(&loc)
	if err != nil {
		resp.Diagnostics.AddError("error creating tfid", err.Error())
		return
	}
	state.Tfid = types.StringValue(tfid)

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *VirtualRouterResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Parse the location from tfid.
	var loc VirtualRouterResourceTfid
	if err := DecodeLocation(state.Tfid.ValueString(), &loc); err != nil {
		resp.Diagnostics.AddError("error parsing tfid", err.Error())
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Delete",
		"name":          loc.Name,
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	err := r.manager.Delete(ctx, loc.Location, []string{loc.Name})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

func (r *VirtualRouterResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

type VirtualRouterNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterLocation struct {
	Ngfw          *VirtualRouterNgfwLocation          `tfsdk:"ngfw"`
	Template      *VirtualRouterTemplateLocation      `tfsdk:"template"`
	TemplateStack *VirtualRouterTemplateStackLocation `tfsdk:"template_stack"`
}

func VirtualRouterLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template stack.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}
