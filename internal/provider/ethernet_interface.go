package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/interface/ethernet"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &EthernetInterfaceDataSource{}
	_ datasource.DataSourceWithConfigure = &EthernetInterfaceDataSource{}
)

func NewEthernetInterfaceDataSource() datasource.DataSource {
	return &EthernetInterfaceDataSource{}
}

type EthernetInterfaceDataSource struct {
	client  *pango.Client
	manager *sdkmanager.ImportableEntryObjectManager[*ethernet.Entry, ethernet.Location, ethernet.ImportLocation, *ethernet.Service]
}

type EthernetInterfaceDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}
type EthernetInterfaceDataSourceTfid struct {
	Name     string            `json:"name"`
	Location ethernet.Location `json:"location"`
}

func (o *EthernetInterfaceDataSourceTfid) IsValid() error {
	if o.Name == "" {
		return fmt.Errorf("name is unspecified")
	}
	return o.Location.IsValid()
}

type EthernetInterfaceDataSourceModel struct {
	Tfid       types.String                             `tfsdk:"tfid"`
	Location   EthernetInterfaceLocation                `tfsdk:"location"`
	Name       types.String                             `tfsdk:"name"`
	LinkSpeed  types.String                             `tfsdk:"link_speed"`
	LinkDuplex types.String                             `tfsdk:"link_duplex"`
	Poe        *EthernetInterfaceDataSourcePoeObject    `tfsdk:"poe"`
	Comment    types.String                             `tfsdk:"comment"`
	LinkState  types.String                             `tfsdk:"link_state"`
	Tap        *EthernetInterfaceDataSourceTapObject    `tfsdk:"tap"`
	Ha         *EthernetInterfaceDataSourceHaObject     `tfsdk:"ha"`
	Layer3     *EthernetInterfaceDataSourceLayer3Object `tfsdk:"layer3"`
}
type EthernetInterfaceDataSourcePoeObject struct {
	Enabled       types.Bool  `tfsdk:"enabled"`
	ReservedPower types.Int64 `tfsdk:"reserved_power"`
}
type EthernetInterfaceDataSourceTapObject struct {
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceDataSourceHaObject struct {
}
type EthernetInterfaceDataSourceLayer3Object struct {
	NdpProxy                   types.Bool                                                `tfsdk:"ndp_proxy"`
	Lldp                       *EthernetInterfaceDataSourceLayer3LldpObject              `tfsdk:"lldp"`
	NetflowProfile             types.String                                              `tfsdk:"netflow_profile"`
	AdjustTcpMss               *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject      `tfsdk:"adjust_tcp_mss"`
	Bonjour                    *EthernetInterfaceDataSourceLayer3BonjourObject           `tfsdk:"bonjour"`
	SdwanLinkSettings          *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject `tfsdk:"sdwan_link_settings"`
	Arp                        types.List                                                `tfsdk:"arp"`
	Mtu                        types.Int64                                               `tfsdk:"mtu"`
	Ips                        types.List                                                `tfsdk:"ips"`
	Ipv6                       *EthernetInterfaceDataSourceLayer3Ipv6Object              `tfsdk:"ipv6"`
	DhcpClient                 *EthernetInterfaceDataSourceLayer3DhcpClientObject        `tfsdk:"dhcp_client"`
	InterfaceManagementProfile types.String                                              `tfsdk:"interface_management_profile"`
	UntaggedSubInterface       types.Bool                                                `tfsdk:"untagged_sub_interface"`
}
type EthernetInterfaceDataSourceLayer3LldpObject struct {
	Profile types.String `tfsdk:"profile"`
	Enable  types.Bool   `tfsdk:"enable"`
}
type EthernetInterfaceDataSourceLayer3AdjustTcpMssObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	Ipv4MssAdjustment types.Int64 `tfsdk:"ipv4_mss_adjustment"`
	Ipv6MssAdjustment types.Int64 `tfsdk:"ipv6_mss_adjustment"`
}
type EthernetInterfaceDataSourceLayer3ArpObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceDataSourceLayer3IpsObject struct {
	Name         types.String `tfsdk:"name"`
	SdwanGateway types.String `tfsdk:"sdwan_gateway"`
}
type EthernetInterfaceDataSourceLayer3Ipv6Object struct {
	Addresses         types.List                                                    `tfsdk:"addresses"`
	NeighborDiscovery *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
	DnsServer         *EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject         `tfsdk:"dns_server"`
	Enabled           types.Bool                                                    `tfsdk:"enabled"`
	InterfaceId       types.String                                                  `tfsdk:"interface_id"`
}
type EthernetInterfaceDataSourceLayer3Ipv6AddressesObject struct {
	Name              types.String                                                   `tfsdk:"name"`
	EnableOnInterface types.Bool                                                     `tfsdk:"enable_on_interface"`
	Prefix            types.String                                                   `tfsdk:"prefix"`
	Anycast           types.String                                                   `tfsdk:"anycast"`
	Advertise         *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject `tfsdk:"advertise"`
}
type EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject struct {
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject struct {
	RouterAdvertisement *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject `tfsdk:"router_advertisement"`
	Neighbor            types.List                                                                       `tfsdk:"neighbor"`
	EnableNdpMonitor    types.Bool                                                                       `tfsdk:"enable_ndp_monitor"`
	EnableDad           types.Bool                                                                       `tfsdk:"enable_dad"`
	DadAttempts         types.Int64                                                                      `tfsdk:"dad_attempts"`
	NsInterval          types.Int64                                                                      `tfsdk:"ns_interval"`
	ReachableTime       types.Int64                                                                      `tfsdk:"reachable_time"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject struct {
	RouterPreference       types.String `tfsdk:"router_preference"`
	Enable                 types.Bool   `tfsdk:"enable"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject struct {
	Enable     types.Bool                                                      `tfsdk:"enable"`
	Source     *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject     `tfsdk:"source"`
	DnsSupport *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject `tfsdk:"dns_support"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject struct {
	Dhcpv6 *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject `tfsdk:"manual"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject struct {
	Enable types.Bool `tfsdk:"enable"`
	Server types.List `tfsdk:"server"`
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3DhcpClientObject struct {
	Enable             types.Bool                                                     `tfsdk:"enable"`
	CreateDefaultRoute types.Bool                                                     `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64                                                    `tfsdk:"default_route_metric"`
	SendHostname       *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject `tfsdk:"send_hostname"`
}
type EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Hostname types.String `tfsdk:"hostname"`
}
type EthernetInterfaceDataSourceLayer3BonjourObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject struct {
	SdwanInterfaceProfile types.String                                                         `tfsdk:"sdwan_interface_profile"`
	UpstreamNat           *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject `tfsdk:"upstream_nat"`
	Enable                types.Bool                                                           `tfsdk:"enable"`
}
type EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	StaticIp types.String `tfsdk:"static_ip"`
}

func (o *EthernetInterfaceDataSourceModel) CopyToPango(ctx context.Context, obj **ethernet.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	comment_value := o.Comment.ValueStringPointer()
	linkState_value := o.LinkState.ValueStringPointer()
	linkSpeed_value := o.LinkSpeed.ValueStringPointer()
	linkDuplex_value := o.LinkDuplex.ValueStringPointer()
	var poe_entry *ethernet.Poe
	if o.Poe != nil {
		if *obj != nil && (*obj).Poe != nil {
			poe_entry = (*obj).Poe
		} else {
			poe_entry = new(ethernet.Poe)
		}

		diags.Append(o.Poe.CopyToPango(ctx, &poe_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tap_entry *ethernet.Tap
	if o.Tap != nil {
		if *obj != nil && (*obj).Tap != nil {
			tap_entry = (*obj).Tap
		} else {
			tap_entry = new(ethernet.Tap)
		}

		diags.Append(o.Tap.CopyToPango(ctx, &tap_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_entry *ethernet.Ha
	if o.Ha != nil {
		if *obj != nil && (*obj).Ha != nil {
			ha_entry = (*obj).Ha
		} else {
			ha_entry = new(ethernet.Ha)
		}

		diags.Append(o.Ha.CopyToPango(ctx, &ha_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_entry *ethernet.Layer3
	if o.Layer3 != nil {
		if *obj != nil && (*obj).Layer3 != nil {
			layer3_entry = (*obj).Layer3
		} else {
			layer3_entry = new(ethernet.Layer3)
		}

		diags.Append(o.Layer3.CopyToPango(ctx, &layer3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Comment = comment_value
	(*obj).LinkState = linkState_value
	(*obj).LinkSpeed = linkSpeed_value
	(*obj).LinkDuplex = linkDuplex_value
	(*obj).Poe = poe_entry
	(*obj).Tap = tap_entry
	(*obj).Ha = ha_entry
	(*obj).Layer3 = layer3_entry

	return diags
}
func (o *EthernetInterfaceDataSourcePoeObject) CopyToPango(ctx context.Context, obj **ethernet.Poe, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	reservedPower_value := o.ReservedPower.ValueInt64Pointer()
	enabled_value := o.Enabled.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Poe)
	}
	(*obj).ReservedPower = reservedPower_value
	(*obj).Enabled = enabled_value

	return diags
}
func (o *EthernetInterfaceDataSourceTapObject) CopyToPango(ctx context.Context, obj **ethernet.Tap, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Tap)
	}
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceDataSourceHaObject) CopyToPango(ctx context.Context, obj **ethernet.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Ha)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Object) CopyToPango(ctx context.Context, obj **ethernet.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ndpProxy_value := o.NdpProxy.ValueBoolPointer()
	var lldp_entry *ethernet.Layer3Lldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.Layer3Lldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()
	var adjustTcpMss_entry *ethernet.Layer3AdjustTcpMss
	if o.AdjustTcpMss != nil {
		if *obj != nil && (*obj).AdjustTcpMss != nil {
			adjustTcpMss_entry = (*obj).AdjustTcpMss
		} else {
			adjustTcpMss_entry = new(ethernet.Layer3AdjustTcpMss)
		}

		diags.Append(o.AdjustTcpMss.CopyToPango(ctx, &adjustTcpMss_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bonjour_entry *ethernet.Layer3Bonjour
	if o.Bonjour != nil {
		if *obj != nil && (*obj).Bonjour != nil {
			bonjour_entry = (*obj).Bonjour
		} else {
			bonjour_entry = new(ethernet.Layer3Bonjour)
		}

		diags.Append(o.Bonjour.CopyToPango(ctx, &bonjour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_entry *ethernet.Layer3SdwanLinkSettings
	if o.SdwanLinkSettings != nil {
		if *obj != nil && (*obj).SdwanLinkSettings != nil {
			sdwanLinkSettings_entry = (*obj).SdwanLinkSettings
		} else {
			sdwanLinkSettings_entry = new(ethernet.Layer3SdwanLinkSettings)
		}

		diags.Append(o.SdwanLinkSettings.CopyToPango(ctx, &sdwanLinkSettings_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var arp_tf_entries []EthernetInterfaceDataSourceLayer3ArpObject
	var arp_pango_entries []ethernet.Layer3Arp
	{
		d := o.Arp.ElementsAs(ctx, &arp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range arp_tf_entries {
			var entry *ethernet.Layer3Arp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			arp_pango_entries = append(arp_pango_entries, *entry)
		}
	}
	mtu_value := o.Mtu.ValueInt64Pointer()
	var ips_tf_entries []EthernetInterfaceDataSourceLayer3IpsObject
	var ips_pango_entries []ethernet.Layer3Ips
	{
		d := o.Ips.ElementsAs(ctx, &ips_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ips_tf_entries {
			var entry *ethernet.Layer3Ips
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ips_pango_entries = append(ips_pango_entries, *entry)
		}
	}
	var ipv6_entry *ethernet.Layer3Ipv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(ethernet.Layer3Ipv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_entry *ethernet.Layer3DhcpClient
	if o.DhcpClient != nil {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(ethernet.Layer3DhcpClient)
		}

		diags.Append(o.DhcpClient.CopyToPango(ctx, &dhcpClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceManagementProfile_value := o.InterfaceManagementProfile.ValueStringPointer()
	untaggedSubInterface_value := o.UntaggedSubInterface.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3)
	}
	(*obj).NdpProxy = ndpProxy_value
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value
	(*obj).AdjustTcpMss = adjustTcpMss_entry
	(*obj).Bonjour = bonjour_entry
	(*obj).SdwanLinkSettings = sdwanLinkSettings_entry
	(*obj).Arp = arp_pango_entries
	(*obj).Mtu = mtu_value
	(*obj).Ips = ips_pango_entries
	(*obj).Ipv6 = ipv6_entry
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).InterfaceManagementProfile = interfaceManagementProfile_value
	(*obj).UntaggedSubInterface = untaggedSubInterface_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3BonjourObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Bonjour)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	sdwanInterfaceProfile_value := o.SdwanInterfaceProfile.ValueStringPointer()
	var upstreamNat_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNat
	if o.UpstreamNat != nil {
		if *obj != nil && (*obj).UpstreamNat != nil {
			upstreamNat_entry = (*obj).UpstreamNat
		} else {
			upstreamNat_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
		}

		diags.Append(o.UpstreamNat.CopyToPango(ctx, &upstreamNat_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettings)
	}
	(*obj).Enable = enable_value
	(*obj).SdwanInterfaceProfile = sdwanInterfaceProfile_value
	(*obj).UpstreamNat = upstreamNat_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	staticIp_value := o.StaticIp.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
	}
	(*obj).Enable = enable_value
	(*obj).StaticIp = staticIp_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3ArpObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Arp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3IpsObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ips, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanGateway_value := o.SdwanGateway.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ips)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SdwanGateway = sdwanGateway_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	interfaceId_value := o.InterfaceId.ValueStringPointer()
	var addresses_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6AddressesObject
	var addresses_pango_entries []ethernet.Layer3Ipv6Addresses
	{
		d := o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addresses_tf_entries {
			var entry *ethernet.Layer3Ipv6Addresses
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addresses_pango_entries = append(addresses_pango_entries, *entry)
		}
	}
	var neighborDiscovery_entry *ethernet.Layer3Ipv6NeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6NeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsServer_entry *ethernet.Layer3Ipv6DnsServer
	if o.DnsServer != nil {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(ethernet.Layer3Ipv6DnsServer)
		}

		diags.Append(o.DnsServer.CopyToPango(ctx, &dnsServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6)
	}
	(*obj).Enabled = enabled_value
	(*obj).InterfaceId = interfaceId_value
	(*obj).Addresses = addresses_pango_entries
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).DnsServer = dnsServer_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6Addresses, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	anycast_value := o.Anycast.ValueStringPointer()
	var advertise_entry *ethernet.Layer3Ipv6AddressesAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6AddressesAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	prefix_value := o.Prefix.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6Addresses)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Anycast = anycast_value
	(*obj).Advertise = advertise_entry
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Prefix = prefix_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6AddressesAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressesAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement
	if o.RouterAdvertisement != nil {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
		}

		diags.Append(o.RouterAdvertisement.CopyToPango(ctx, &routerAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	enableDad_value := o.EnableDad.ValueBoolPointer()
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	nsInterval_value := o.NsInterval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscovery)
	}
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).EnableDad = enableDad_value
	(*obj).DadAttempts = dadAttempts_value
	(*obj).NsInterval = nsInterval_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
	}
	(*obj).MinInterval = minInterval_value
	(*obj).Lifetime = lifetime_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).Enable = enable_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).HopLimit = hopLimit_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_entry *ethernet.Layer3Ipv6DnsServerDnsSupport
	if o.DnsSupport != nil {
		if *obj != nil && (*obj).DnsSupport != nil {
			dnsSupport_entry = (*obj).DnsSupport
		} else {
			dnsSupport_entry = new(ethernet.Layer3Ipv6DnsServerDnsSupport)
		}

		diags.Append(o.DnsSupport.CopyToPango(ctx, &dnsSupport_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6DnsServerSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6DnsServerSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServer)
	}
	(*obj).DnsSupport = dnsSupport_entry
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6DnsServerSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6DnsServerSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6DnsServerSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6DnsServerSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6DnsServerSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6DnsServerSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject
	var server_pango_entries []ethernet.Layer3Ipv6DnsServerDnsSupportServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6DnsServerDnsSupportServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}
	var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6DnsServerDnsSupportSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6DnsServerDnsSupportSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerDnsSupport)
	}
	(*obj).Enable = enable_value
	(*obj).Server = server_pango_entries
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerDnsSupportServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerDnsSupportSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	var sendHostname_entry *ethernet.Layer3DhcpClientSendHostname
	if o.SendHostname != nil {
		if *obj != nil && (*obj).SendHostname != nil {
			sendHostname_entry = (*obj).SendHostname
		} else {
			sendHostname_entry = new(ethernet.Layer3DhcpClientSendHostname)
		}

		diags.Append(o.SendHostname.CopyToPango(ctx, &sendHostname_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClient)
	}
	(*obj).Enable = enable_value
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).SendHostname = sendHostname_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClientSendHostname)
	}
	(*obj).Enable = enable_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3LldpObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	ipv4MssAdjustment_value := o.Ipv4MssAdjustment.ValueInt64Pointer()
	ipv6MssAdjustment_value := o.Ipv6MssAdjustment.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3AdjustTcpMss)
	}
	(*obj).Enable = enable_value
	(*obj).Ipv4MssAdjustment = ipv4MssAdjustment_value
	(*obj).Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}

func (o *EthernetInterfaceDataSourceModel) CopyFromPango(ctx context.Context, obj *ethernet.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var poe_object *EthernetInterfaceDataSourcePoeObject
	if obj.Poe != nil {
		poe_object = new(EthernetInterfaceDataSourcePoeObject)

		diags.Append(poe_object.CopyFromPango(ctx, obj.Poe, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tap_object *EthernetInterfaceDataSourceTapObject
	if obj.Tap != nil {
		tap_object = new(EthernetInterfaceDataSourceTapObject)

		diags.Append(tap_object.CopyFromPango(ctx, obj.Tap, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_object *EthernetInterfaceDataSourceHaObject
	if obj.Ha != nil {
		ha_object = new(EthernetInterfaceDataSourceHaObject)

		diags.Append(ha_object.CopyFromPango(ctx, obj.Ha, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_object *EthernetInterfaceDataSourceLayer3Object
	if obj.Layer3 != nil {
		layer3_object = new(EthernetInterfaceDataSourceLayer3Object)

		diags.Append(layer3_object.CopyFromPango(ctx, obj.Layer3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var linkState_value types.String
	if obj.LinkState != nil {
		linkState_value = types.StringValue(*obj.LinkState)
	}
	var linkSpeed_value types.String
	if obj.LinkSpeed != nil {
		linkSpeed_value = types.StringValue(*obj.LinkSpeed)
	}
	var linkDuplex_value types.String
	if obj.LinkDuplex != nil {
		linkDuplex_value = types.StringValue(*obj.LinkDuplex)
	}
	o.Name = types.StringValue(obj.Name)
	o.Comment = comment_value
	o.LinkState = linkState_value
	o.LinkSpeed = linkSpeed_value
	o.LinkDuplex = linkDuplex_value
	o.Poe = poe_object
	o.Tap = tap_object
	o.Ha = ha_object
	o.Layer3 = layer3_object

	return diags
}

func (o *EthernetInterfaceDataSourcePoeObject) CopyFromPango(ctx context.Context, obj *ethernet.Poe, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var reservedPower_value types.Int64
	if obj.ReservedPower != nil {
		reservedPower_value = types.Int64Value(*obj.ReservedPower)
	}
	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.ReservedPower = reservedPower_value
	o.Enabled = enabled_value

	return diags
}

func (o *EthernetInterfaceDataSourceTapObject) CopyFromPango(ctx context.Context, obj *ethernet.Tap, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceDataSourceHaObject) CopyFromPango(ctx context.Context, obj *ethernet.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Object) CopyFromPango(ctx context.Context, obj *ethernet.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var arp_list types.List
	{
		var arp_tf_entries []EthernetInterfaceDataSourceLayer3ArpObject
		for _, elt := range obj.Arp {
			var entry EthernetInterfaceDataSourceLayer3ArpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			arp_tf_entries = append(arp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("arp")
		arp_list, list_diags = types.ListValueFrom(ctx, schemaType, arp_tf_entries)
		diags.Append(list_diags...)
	}
	var ips_list types.List
	{
		var ips_tf_entries []EthernetInterfaceDataSourceLayer3IpsObject
		for _, elt := range obj.Ips {
			var entry EthernetInterfaceDataSourceLayer3IpsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ips_tf_entries = append(ips_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ips")
		ips_list, list_diags = types.ListValueFrom(ctx, schemaType, ips_tf_entries)
		diags.Append(list_diags...)
	}
	var adjustTcpMss_object *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject
	if obj.AdjustTcpMss != nil {
		adjustTcpMss_object = new(EthernetInterfaceDataSourceLayer3AdjustTcpMssObject)

		diags.Append(adjustTcpMss_object.CopyFromPango(ctx, obj.AdjustTcpMss, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_object *EthernetInterfaceDataSourceLayer3LldpObject
	if obj.Lldp != nil {
		lldp_object = new(EthernetInterfaceDataSourceLayer3LldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *EthernetInterfaceDataSourceLayer3Ipv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(EthernetInterfaceDataSourceLayer3Ipv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_object *EthernetInterfaceDataSourceLayer3DhcpClientObject
	if obj.DhcpClient != nil {
		dhcpClient_object = new(EthernetInterfaceDataSourceLayer3DhcpClientObject)

		diags.Append(dhcpClient_object.CopyFromPango(ctx, obj.DhcpClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bonjour_object *EthernetInterfaceDataSourceLayer3BonjourObject
	if obj.Bonjour != nil {
		bonjour_object = new(EthernetInterfaceDataSourceLayer3BonjourObject)

		diags.Append(bonjour_object.CopyFromPango(ctx, obj.Bonjour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_object *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject
	if obj.SdwanLinkSettings != nil {
		sdwanLinkSettings_object = new(EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject)

		diags.Append(sdwanLinkSettings_object.CopyFromPango(ctx, obj.SdwanLinkSettings, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ndpProxy_value types.Bool
	if obj.NdpProxy != nil {
		ndpProxy_value = types.BoolValue(*obj.NdpProxy)
	}
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	var interfaceManagementProfile_value types.String
	if obj.InterfaceManagementProfile != nil {
		interfaceManagementProfile_value = types.StringValue(*obj.InterfaceManagementProfile)
	}
	var mtu_value types.Int64
	if obj.Mtu != nil {
		mtu_value = types.Int64Value(*obj.Mtu)
	}
	var untaggedSubInterface_value types.Bool
	if obj.UntaggedSubInterface != nil {
		untaggedSubInterface_value = types.BoolValue(*obj.UntaggedSubInterface)
	}
	o.AdjustTcpMss = adjustTcpMss_object
	o.NdpProxy = ndpProxy_value
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value
	o.Ipv6 = ipv6_object
	o.DhcpClient = dhcpClient_object
	o.InterfaceManagementProfile = interfaceManagementProfile_value
	o.Bonjour = bonjour_object
	o.SdwanLinkSettings = sdwanLinkSettings_object
	o.Arp = arp_list
	o.Mtu = mtu_value
	o.Ips = ips_list
	o.UntaggedSubInterface = untaggedSubInterface_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3IpsObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ips, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sdwanGateway_value types.String
	if obj.SdwanGateway != nil {
		sdwanGateway_value = types.StringValue(*obj.SdwanGateway)
	}
	o.Name = types.StringValue(obj.Name)
	o.SdwanGateway = sdwanGateway_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_list types.List
	{
		var addresses_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6AddressesObject
		for _, elt := range obj.Addresses {
			var entry EthernetInterfaceDataSourceLayer3Ipv6AddressesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addresses_tf_entries = append(addresses_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("addresses")
		addresses_list, list_diags = types.ListValueFrom(ctx, schemaType, addresses_tf_entries)
		diags.Append(list_diags...)
	}
	var neighborDiscovery_object *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsServer_object *EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject
	if obj.DnsServer != nil {
		dnsServer_object = new(EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject)

		diags.Append(dnsServer_object.CopyFromPango(ctx, obj.DnsServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	var interfaceId_value types.String
	if obj.InterfaceId != nil {
		interfaceId_value = types.StringValue(*obj.InterfaceId)
	}
	o.Enabled = enabled_value
	o.InterfaceId = interfaceId_value
	o.Addresses = addresses_list
	o.NeighborDiscovery = neighborDiscovery_object
	o.DnsServer = dnsServer_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6Addresses, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var prefix_value types.String
	if obj.Prefix != nil {
		prefix_value = types.StringValue(*obj.Prefix)
	}
	var anycast_value types.String
	if obj.Anycast != nil {
		anycast_value = types.StringValue(*obj.Anycast)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.EnableOnInterface = enableOnInterface_value
	o.Prefix = prefix_value
	o.Anycast = anycast_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6AddressesAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var routerAdvertisement_object *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	if obj.RouterAdvertisement != nil {
		routerAdvertisement_object = new(EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject)

		diags.Append(routerAdvertisement_object.CopyFromPango(ctx, obj.RouterAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.EnableDad = enableDad_value
	o.DadAttempts = dadAttempts_value
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object
	o.Neighbor = neighbor_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.MinInterval = minInterval_value
	o.Lifetime = lifetime_value
	o.ManagedFlag = managedFlag_value
	o.OtherFlag = otherFlag_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.Enable = enable_value
	o.MaxInterval = maxInterval_value
	o.LinkMtu = linkMtu_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.HopLimit = hopLimit_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_object *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject
	if obj.DnsSupport != nil {
		dnsSupport_object = new(EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject)

		diags.Append(dnsSupport_object.CopyFromPango(ctx, obj.DnsSupport, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var source_object *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject
	if obj.Source != nil {
		source_object = new(EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.DnsSupport = dnsSupport_object
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject
		for _, elt := range obj.Server {
			var entry EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject
		for _, elt := range obj.Suffix {
			var entry EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Server = server_list
	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject
	if obj.Manual != nil {
		manual_object = new(EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject
		for _, elt := range obj.Suffix {
			var entry EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}
	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sendHostname_object *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject
	if obj.SendHostname != nil {
		sendHostname_object = new(EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject)

		diags.Append(sendHostname_object.CopyFromPango(ctx, obj.SendHostname, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.Enable = enable_value
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.SendHostname = sendHostname_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.Enable = enable_value
	o.Hostname = hostname_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3BonjourObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var upstreamNat_object *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject
	if obj.UpstreamNat != nil {
		upstreamNat_object = new(EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject)

		diags.Append(upstreamNat_object.CopyFromPango(ctx, obj.UpstreamNat, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var sdwanInterfaceProfile_value types.String
	if obj.SdwanInterfaceProfile != nil {
		sdwanInterfaceProfile_value = types.StringValue(*obj.SdwanInterfaceProfile)
	}
	o.Enable = enable_value
	o.SdwanInterfaceProfile = sdwanInterfaceProfile_value
	o.UpstreamNat = upstreamNat_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var staticIp_value types.String
	if obj.StaticIp != nil {
		staticIp_value = types.StringValue(*obj.StaticIp)
	}
	o.Enable = enable_value
	o.StaticIp = staticIp_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3ArpObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3LldpObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Profile = profile_value
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var ipv4MssAdjustment_value types.Int64
	if obj.Ipv4MssAdjustment != nil {
		ipv4MssAdjustment_value = types.Int64Value(*obj.Ipv4MssAdjustment)
	}
	var ipv6MssAdjustment_value types.Int64
	if obj.Ipv6MssAdjustment != nil {
		ipv6MssAdjustment_value = types.Int64Value(*obj.Ipv6MssAdjustment)
	}
	o.Enable = enable_value
	o.Ipv4MssAdjustment = ipv4MssAdjustment_value
	o.Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}

func EthernetInterfaceDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": EthernetInterfaceDataSourceLocationSchema(),

			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				Required:    false,
				Optional:    false,
				Sensitive:   false,
			},

			"name": dsschema.StringAttribute{
				Description: "The name of the ethernet interface.",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_state": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_speed": dsschema.StringAttribute{
				Description: "Interface link speed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_duplex": dsschema.StringAttribute{
				Description: "Interface link duplex",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"poe": EthernetInterfaceDataSourcePoeSchema(),

			"layer3": EthernetInterfaceDataSourceLayer3Schema(),

			"tap": EthernetInterfaceDataSourceTapSchema(),

			"ha": EthernetInterfaceDataSourceHaSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceModel) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourcePoeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"reserved_power": dsschema.Int64Attribute{
				Description: "Reserved Power",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enabled": dsschema.BoolAttribute{
				Description: "PoE Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourcePoeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourcePoeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("tap"),
				path.MatchRelative().AtParent().AtName("ha"),
				path.MatchRelative().AtParent().AtName("layer3"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"bonjour": EthernetInterfaceDataSourceLayer3BonjourSchema(),

			"sdwan_link_settings": EthernetInterfaceDataSourceLayer3SdwanLinkSettingsSchema(),

			"arp": dsschema.ListNestedAttribute{
				Description:  "ARP configuration",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3ArpSchema(),
			},

			"mtu": dsschema.Int64Attribute{
				Description: "Maximum Transfer Unit, up to 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ips": dsschema.ListNestedAttribute{
				Description:  "IP addresses or address objects names",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3IpsSchema(),
			},

			"ipv6": EthernetInterfaceDataSourceLayer3Ipv6Schema(),

			"dhcp_client": EthernetInterfaceDataSourceLayer3DhcpClientSchema(),

			"interface_management_profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"untagged_sub_interface": dsschema.BoolAttribute{
				Description: "Enable untagged sub-interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ndp_proxy": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lldp": EthernetInterfaceDataSourceLayer3LldpSchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"adjust_tcp_mss": EthernetInterfaceDataSourceLayer3AdjustTcpMssSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3LldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3LldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3AdjustTcpMssSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4_mss_adjustment": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_mss_adjustment": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3AdjustTcpMssSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3IpsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"sdwan_gateway": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3IpsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3IpsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enabled": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_id": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"addresses": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6AddressesSchema(),
			},

			"neighbor_discovery": EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema(),

			"dns_server": EthernetInterfaceDataSourceLayer3Ipv6DnsServerSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceSchema(),

			"dns_support": EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Schema(),

			"manual": EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"suffix": dsschema.ListNestedAttribute{
				Description:  "DNS suffixes",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": dsschema.ListNestedAttribute{
				Description:  "DNS Recusrive Name Server",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerSchema(),
			},

			"suffix": dsschema.ListNestedAttribute{
				Description:  "Domain Search List",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DnsServerDnsSupportSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6AddressesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "configure this address on interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": dsschema.StringAttribute{
				Description: "use this as prefix to form full address with interface id/EUI-64",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anycast": dsschema.StringAttribute{
				Description: "anycast address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertise": EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6AddressesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"preferred_lifetime": dsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": dsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix adverised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ns_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_advertisement": EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema(),

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema(),
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_dad": dsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dad_attempts": dsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": dsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_mtu": dsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmission_timer": dsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": dsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_preference": dsschema.StringAttribute{
				Description: "Router Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_interval": dsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"managed_flag": dsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"other_flag": dsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": dsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3DhcpClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"create_default_route": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_hostname": EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3BonjourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Set to support Bonjour service",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3BonjourObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3BonjourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3SdwanLinkSettingsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_interface_profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"upstream_nat": EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3SdwanLinkSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ip": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3ArpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3ArpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3ArpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceTapSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"netflow_profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceTapObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceTapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceHaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceHaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceHaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLocationSchema() rsschema.Attribute {
	return EthernetInterfaceLocationSchema()
}

// Metadata returns the data source type name.
func (d *EthernetInterfaceDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ethernet_interface"
}

// Schema defines the schema for this data source.
func (d *EthernetInterfaceDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = EthernetInterfaceDataSourceSchema()
}

// Configure prepares the struct.
func (d *EthernetInterfaceDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := ethernet.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewImportableEntryObjectManager(d.client, ethernet.NewService(d.client), specifier, ethernet.SpecMatches)
}

func (o *EthernetInterfaceDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state EthernetInterfaceDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var loc EthernetInterfaceDataSourceTfid
	loc.Name = *savestate.Name.ValueStringPointer()

	if savestate.Location.Ngfw != nil {
		loc.Location.Ngfw = &ethernet.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		loc.Location.Template = &ethernet.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		loc.Location.TemplateStack = &ethernet.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Read",
		"name":          loc.Name,
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, loc.Location, loc.Name)
	if err != nil {
		tflog.Warn(ctx, "KK: HERE3-1", map[string]any{"Error": err.Error()})
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location
	// Save tfid to state.
	state.Tfid = savestate.Tfid

	// Save the answer to state.

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &EthernetInterfaceResource{}
	_ resource.ResourceWithConfigure   = &EthernetInterfaceResource{}
	_ resource.ResourceWithImportState = &EthernetInterfaceResource{}
)

func NewEthernetInterfaceResource() resource.Resource {
	return &EthernetInterfaceResource{}
}

type EthernetInterfaceResource struct {
	client  *pango.Client
	manager *sdkmanager.ImportableEntryObjectManager[*ethernet.Entry, ethernet.Location, ethernet.ImportLocation, *ethernet.Service]
}
type EthernetInterfaceResourceTfid struct {
	Name     string            `json:"name"`
	Location ethernet.Location `json:"location"`
}

func (o *EthernetInterfaceResourceTfid) IsValid() error {
	if o.Name == "" {
		return fmt.Errorf("name is unspecified")
	}
	return o.Location.IsValid()
}

func EthernetInterfaceResourceLocationSchema() rsschema.Attribute {
	return EthernetInterfaceLocationSchema()
}

type EthernetInterfaceResourceModel struct {
	Tfid       types.String                           `tfsdk:"tfid"`
	Location   EthernetInterfaceLocation              `tfsdk:"location"`
	Name       types.String                           `tfsdk:"name"`
	LinkDuplex types.String                           `tfsdk:"link_duplex"`
	Poe        *EthernetInterfaceResourcePoeObject    `tfsdk:"poe"`
	Comment    types.String                           `tfsdk:"comment"`
	LinkState  types.String                           `tfsdk:"link_state"`
	LinkSpeed  types.String                           `tfsdk:"link_speed"`
	Ha         *EthernetInterfaceResourceHaObject     `tfsdk:"ha"`
	Layer3     *EthernetInterfaceResourceLayer3Object `tfsdk:"layer3"`
	Tap        *EthernetInterfaceResourceTapObject    `tfsdk:"tap"`
}
type EthernetInterfaceResourcePoeObject struct {
	ReservedPower types.Int64 `tfsdk:"reserved_power"`
	Enabled       types.Bool  `tfsdk:"enabled"`
}
type EthernetInterfaceResourceHaObject struct {
}
type EthernetInterfaceResourceLayer3Object struct {
	Arp                        types.List                                              `tfsdk:"arp"`
	Mtu                        types.Int64                                             `tfsdk:"mtu"`
	Ips                        types.List                                              `tfsdk:"ips"`
	Ipv6                       *EthernetInterfaceResourceLayer3Ipv6Object              `tfsdk:"ipv6"`
	DhcpClient                 *EthernetInterfaceResourceLayer3DhcpClientObject        `tfsdk:"dhcp_client"`
	InterfaceManagementProfile types.String                                            `tfsdk:"interface_management_profile"`
	Bonjour                    *EthernetInterfaceResourceLayer3BonjourObject           `tfsdk:"bonjour"`
	SdwanLinkSettings          *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject `tfsdk:"sdwan_link_settings"`
	UntaggedSubInterface       types.Bool                                              `tfsdk:"untagged_sub_interface"`
	NdpProxy                   types.Bool                                              `tfsdk:"ndp_proxy"`
	Lldp                       *EthernetInterfaceResourceLayer3LldpObject              `tfsdk:"lldp"`
	NetflowProfile             types.String                                            `tfsdk:"netflow_profile"`
	AdjustTcpMss               *EthernetInterfaceResourceLayer3AdjustTcpMssObject      `tfsdk:"adjust_tcp_mss"`
}
type EthernetInterfaceResourceLayer3Ipv6Object struct {
	Enabled           types.Bool                                                  `tfsdk:"enabled"`
	InterfaceId       types.String                                                `tfsdk:"interface_id"`
	Addresses         types.List                                                  `tfsdk:"addresses"`
	NeighborDiscovery *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
	DnsServer         *EthernetInterfaceResourceLayer3Ipv6DnsServerObject         `tfsdk:"dns_server"`
}
type EthernetInterfaceResourceLayer3Ipv6AddressesObject struct {
	Name              types.String                                                 `tfsdk:"name"`
	EnableOnInterface types.Bool                                                   `tfsdk:"enable_on_interface"`
	Prefix            types.String                                                 `tfsdk:"prefix"`
	Anycast           types.String                                                 `tfsdk:"anycast"`
	Advertise         *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject `tfsdk:"advertise"`
}
type EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject struct {
	RouterAdvertisement *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject `tfsdk:"router_advertisement"`
	Neighbor            types.List                                                                     `tfsdk:"neighbor"`
	EnableNdpMonitor    types.Bool                                                                     `tfsdk:"enable_ndp_monitor"`
	EnableDad           types.Bool                                                                     `tfsdk:"enable_dad"`
	DadAttempts         types.Int64                                                                    `tfsdk:"dad_attempts"`
	NsInterval          types.Int64                                                                    `tfsdk:"ns_interval"`
	ReachableTime       types.Int64                                                                    `tfsdk:"reachable_time"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject struct {
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	Enable                 types.Bool   `tfsdk:"enable"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerObject struct {
	Enable     types.Bool                                                    `tfsdk:"enable"`
	Source     *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject     `tfsdk:"source"`
	DnsSupport *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject `tfsdk:"dns_support"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject struct {
	Dhcpv6 *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject `tfsdk:"manual"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject struct {
	Enable types.Bool `tfsdk:"enable"`
	Server types.List `tfsdk:"server"`
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3DhcpClientObject struct {
	Enable             types.Bool                                                   `tfsdk:"enable"`
	CreateDefaultRoute types.Bool                                                   `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64                                                  `tfsdk:"default_route_metric"`
	SendHostname       *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject `tfsdk:"send_hostname"`
}
type EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject struct {
	Hostname types.String `tfsdk:"hostname"`
	Enable   types.Bool   `tfsdk:"enable"`
}
type EthernetInterfaceResourceLayer3BonjourObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type EthernetInterfaceResourceLayer3SdwanLinkSettingsObject struct {
	Enable                types.Bool                                                         `tfsdk:"enable"`
	SdwanInterfaceProfile types.String                                                       `tfsdk:"sdwan_interface_profile"`
	UpstreamNat           *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject `tfsdk:"upstream_nat"`
}
type EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	StaticIp types.String `tfsdk:"static_ip"`
}
type EthernetInterfaceResourceLayer3ArpObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceResourceLayer3IpsObject struct {
	Name         types.String `tfsdk:"name"`
	SdwanGateway types.String `tfsdk:"sdwan_gateway"`
}
type EthernetInterfaceResourceLayer3AdjustTcpMssObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	Ipv4MssAdjustment types.Int64 `tfsdk:"ipv4_mss_adjustment"`
	Ipv6MssAdjustment types.Int64 `tfsdk:"ipv6_mss_adjustment"`
}
type EthernetInterfaceResourceLayer3LldpObject struct {
	Profile types.String `tfsdk:"profile"`
	Enable  types.Bool   `tfsdk:"enable"`
}
type EthernetInterfaceResourceTapObject struct {
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}

func (r *EthernetInterfaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ethernet_interface"
}

func (r *EthernetInterfaceResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func EthernetInterfaceResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": EthernetInterfaceResourceLocationSchema(),

			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				Required:    false,
				Optional:    false,
				Sensitive:   false,
			},

			"name": rsschema.StringAttribute{
				Description: "The name of the ethernet interface.",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"poe": EthernetInterfaceResourcePoeSchema(),

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_state": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("auto"),
			},

			"link_speed": rsschema.StringAttribute{
				Description: "Interface link speed",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_duplex": rsschema.StringAttribute{
				Description: "Interface link duplex",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"layer3": EthernetInterfaceResourceLayer3Schema(),

			"tap": EthernetInterfaceResourceTapSchema(),

			"ha": EthernetInterfaceResourceHaSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceModel) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourcePoeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"reserved_power": rsschema.Int64Attribute{
				Description: "Reserved Power",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enabled": rsschema.BoolAttribute{
				Description: "PoE Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourcePoeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourcePoeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("tap"),
				path.MatchRelative().AtParent().AtName("ha"),
				path.MatchRelative().AtParent().AtName("layer3"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"arp": rsschema.ListNestedAttribute{
				Description:  "ARP configuration",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3ArpSchema(),
			},

			"mtu": rsschema.Int64Attribute{
				Description: "Maximum Transfer Unit, up to 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ips": rsschema.ListNestedAttribute{
				Description:  "IP addresses or address objects names",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3IpsSchema(),
			},

			"ipv6": EthernetInterfaceResourceLayer3Ipv6Schema(),

			"dhcp_client": EthernetInterfaceResourceLayer3DhcpClientSchema(),

			"interface_management_profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bonjour": EthernetInterfaceResourceLayer3BonjourSchema(),

			"sdwan_link_settings": EthernetInterfaceResourceLayer3SdwanLinkSettingsSchema(),

			"untagged_sub_interface": rsschema.BoolAttribute{
				Description: "Enable untagged sub-interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ndp_proxy": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lldp": EthernetInterfaceResourceLayer3LldpSchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"adjust_tcp_mss": EthernetInterfaceResourceLayer3AdjustTcpMssSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface_id": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"addresses": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6AddressesSchema(),
			},

			"neighbor_discovery": EthernetInterfaceResourceLayer3Ipv6NeighborDiscoverySchema(),

			"dns_server": EthernetInterfaceResourceLayer3Ipv6DnsServerSchema(),

			"enabled": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_dad": rsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dad_attempts": rsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_advertisement": EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema(),

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hop_limit": rsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("64"),
			},

			"router_preference": rsschema.StringAttribute{
				Description: "Router Preference",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": rsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_mtu": rsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"reachable_time": rsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"retransmission_timer": rsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"min_interval": rsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"managed_flag": rsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"other_flag": rsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": rsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceResourceLayer3Ipv6DnsServerSourceSchema(),

			"dns_support": EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Schema(),

			"manual": EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"suffix": rsschema.ListNestedAttribute{
				Description:  "DNS suffixes",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": rsschema.ListNestedAttribute{
				Description:  "DNS Recusrive Name Server",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerSchema(),
			},

			"suffix": rsschema.ListNestedAttribute{
				Description:  "Domain Search List",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6AddressesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "configure this address on interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": rsschema.StringAttribute{
				Description: "use this as prefix to form full address with interface id/EUI-64",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anycast": rsschema.StringAttribute{
				Description: "anycast address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertise": EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6AddressesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": rsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix adverised in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred_lifetime": rsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3DhcpClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"send_hostname": EthernetInterfaceResourceLayer3DhcpClientSendHostnameSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"create_default_route": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3DhcpClientSendHostnameSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hostname": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3DhcpClientSendHostnameSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3BonjourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Set to support Bonjour service",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3BonjourObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3BonjourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3SdwanLinkSettingsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"upstream_nat": EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_interface_profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3SdwanLinkSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ip": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3ArpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3ArpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3ArpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3IpsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"sdwan_gateway": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3IpsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3IpsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3AdjustTcpMssSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4_mss_adjustment": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_mss_adjustment": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3AdjustTcpMssSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3LldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3LldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceTapSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"netflow_profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceTapObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceTapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceHaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceHaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceHaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *EthernetInterfaceResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = EthernetInterfaceResourceSchema()
}

// </ResourceSchema>

func (r *EthernetInterfaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := ethernet.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewImportableEntryObjectManager(r.client, ethernet.NewService(r.client), specifier, ethernet.SpecMatches)
}

func (o *EthernetInterfaceResourceModel) CopyToPango(ctx context.Context, obj **ethernet.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	linkDuplex_value := o.LinkDuplex.ValueStringPointer()
	var poe_entry *ethernet.Poe
	if o.Poe != nil {
		if *obj != nil && (*obj).Poe != nil {
			poe_entry = (*obj).Poe
		} else {
			poe_entry = new(ethernet.Poe)
		}

		diags.Append(o.Poe.CopyToPango(ctx, &poe_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	linkState_value := o.LinkState.ValueStringPointer()
	linkSpeed_value := o.LinkSpeed.ValueStringPointer()
	var tap_entry *ethernet.Tap
	if o.Tap != nil {
		if *obj != nil && (*obj).Tap != nil {
			tap_entry = (*obj).Tap
		} else {
			tap_entry = new(ethernet.Tap)
		}

		diags.Append(o.Tap.CopyToPango(ctx, &tap_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_entry *ethernet.Ha
	if o.Ha != nil {
		if *obj != nil && (*obj).Ha != nil {
			ha_entry = (*obj).Ha
		} else {
			ha_entry = new(ethernet.Ha)
		}

		diags.Append(o.Ha.CopyToPango(ctx, &ha_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_entry *ethernet.Layer3
	if o.Layer3 != nil {
		if *obj != nil && (*obj).Layer3 != nil {
			layer3_entry = (*obj).Layer3
		} else {
			layer3_entry = new(ethernet.Layer3)
		}

		diags.Append(o.Layer3.CopyToPango(ctx, &layer3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).LinkDuplex = linkDuplex_value
	(*obj).Poe = poe_entry
	(*obj).Comment = comment_value
	(*obj).LinkState = linkState_value
	(*obj).LinkSpeed = linkSpeed_value
	(*obj).Tap = tap_entry
	(*obj).Ha = ha_entry
	(*obj).Layer3 = layer3_entry

	return diags
}
func (o *EthernetInterfaceResourcePoeObject) CopyToPango(ctx context.Context, obj **ethernet.Poe, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	reservedPower_value := o.ReservedPower.ValueInt64Pointer()
	enabled_value := o.Enabled.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Poe)
	}
	(*obj).ReservedPower = reservedPower_value
	(*obj).Enabled = enabled_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Object) CopyToPango(ctx context.Context, obj **ethernet.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var arp_tf_entries []EthernetInterfaceResourceLayer3ArpObject
	var arp_pango_entries []ethernet.Layer3Arp
	{
		d := o.Arp.ElementsAs(ctx, &arp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range arp_tf_entries {
			var entry *ethernet.Layer3Arp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			arp_pango_entries = append(arp_pango_entries, *entry)
		}
	}
	mtu_value := o.Mtu.ValueInt64Pointer()
	var ips_tf_entries []EthernetInterfaceResourceLayer3IpsObject
	var ips_pango_entries []ethernet.Layer3Ips
	{
		d := o.Ips.ElementsAs(ctx, &ips_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ips_tf_entries {
			var entry *ethernet.Layer3Ips
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ips_pango_entries = append(ips_pango_entries, *entry)
		}
	}
	var ipv6_entry *ethernet.Layer3Ipv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(ethernet.Layer3Ipv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_entry *ethernet.Layer3DhcpClient
	if o.DhcpClient != nil {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(ethernet.Layer3DhcpClient)
		}

		diags.Append(o.DhcpClient.CopyToPango(ctx, &dhcpClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceManagementProfile_value := o.InterfaceManagementProfile.ValueStringPointer()
	var bonjour_entry *ethernet.Layer3Bonjour
	if o.Bonjour != nil {
		if *obj != nil && (*obj).Bonjour != nil {
			bonjour_entry = (*obj).Bonjour
		} else {
			bonjour_entry = new(ethernet.Layer3Bonjour)
		}

		diags.Append(o.Bonjour.CopyToPango(ctx, &bonjour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_entry *ethernet.Layer3SdwanLinkSettings
	if o.SdwanLinkSettings != nil {
		if *obj != nil && (*obj).SdwanLinkSettings != nil {
			sdwanLinkSettings_entry = (*obj).SdwanLinkSettings
		} else {
			sdwanLinkSettings_entry = new(ethernet.Layer3SdwanLinkSettings)
		}

		diags.Append(o.SdwanLinkSettings.CopyToPango(ctx, &sdwanLinkSettings_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	untaggedSubInterface_value := o.UntaggedSubInterface.ValueBoolPointer()
	ndpProxy_value := o.NdpProxy.ValueBoolPointer()
	var lldp_entry *ethernet.Layer3Lldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.Layer3Lldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()
	var adjustTcpMss_entry *ethernet.Layer3AdjustTcpMss
	if o.AdjustTcpMss != nil {
		if *obj != nil && (*obj).AdjustTcpMss != nil {
			adjustTcpMss_entry = (*obj).AdjustTcpMss
		} else {
			adjustTcpMss_entry = new(ethernet.Layer3AdjustTcpMss)
		}

		diags.Append(o.AdjustTcpMss.CopyToPango(ctx, &adjustTcpMss_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3)
	}
	(*obj).Arp = arp_pango_entries
	(*obj).Mtu = mtu_value
	(*obj).Ips = ips_pango_entries
	(*obj).Ipv6 = ipv6_entry
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).InterfaceManagementProfile = interfaceManagementProfile_value
	(*obj).Bonjour = bonjour_entry
	(*obj).SdwanLinkSettings = sdwanLinkSettings_entry
	(*obj).UntaggedSubInterface = untaggedSubInterface_value
	(*obj).NdpProxy = ndpProxy_value
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value
	(*obj).AdjustTcpMss = adjustTcpMss_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3LldpObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	ipv4MssAdjustment_value := o.Ipv4MssAdjustment.ValueInt64Pointer()
	ipv6MssAdjustment_value := o.Ipv6MssAdjustment.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3AdjustTcpMss)
	}
	(*obj).Enable = enable_value
	(*obj).Ipv4MssAdjustment = ipv4MssAdjustment_value
	(*obj).Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3DhcpClientObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	var sendHostname_entry *ethernet.Layer3DhcpClientSendHostname
	if o.SendHostname != nil {
		if *obj != nil && (*obj).SendHostname != nil {
			sendHostname_entry = (*obj).SendHostname
		} else {
			sendHostname_entry = new(ethernet.Layer3DhcpClientSendHostname)
		}

		diags.Append(o.SendHostname.CopyToPango(ctx, &sendHostname_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClient)
	}
	(*obj).Enable = enable_value
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).SendHostname = sendHostname_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClientSendHostname)
	}
	(*obj).Enable = enable_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3BonjourObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Bonjour)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanInterfaceProfile_value := o.SdwanInterfaceProfile.ValueStringPointer()
	var upstreamNat_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNat
	if o.UpstreamNat != nil {
		if *obj != nil && (*obj).UpstreamNat != nil {
			upstreamNat_entry = (*obj).UpstreamNat
		} else {
			upstreamNat_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
		}

		diags.Append(o.UpstreamNat.CopyToPango(ctx, &upstreamNat_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettings)
	}
	(*obj).SdwanInterfaceProfile = sdwanInterfaceProfile_value
	(*obj).UpstreamNat = upstreamNat_entry
	(*obj).Enable = enable_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	staticIp_value := o.StaticIp.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
	}
	(*obj).Enable = enable_value
	(*obj).StaticIp = staticIp_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3ArpObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Arp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3IpsObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ips, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanGateway_value := o.SdwanGateway.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ips)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SdwanGateway = sdwanGateway_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6Object) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighborDiscovery_entry *ethernet.Layer3Ipv6NeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6NeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsServer_entry *ethernet.Layer3Ipv6DnsServer
	if o.DnsServer != nil {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(ethernet.Layer3Ipv6DnsServer)
		}

		diags.Append(o.DnsServer.CopyToPango(ctx, &dnsServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()
	interfaceId_value := o.InterfaceId.ValueStringPointer()
	var addresses_tf_entries []EthernetInterfaceResourceLayer3Ipv6AddressesObject
	var addresses_pango_entries []ethernet.Layer3Ipv6Addresses
	{
		d := o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addresses_tf_entries {
			var entry *ethernet.Layer3Ipv6Addresses
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addresses_pango_entries = append(addresses_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6)
	}
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).DnsServer = dnsServer_entry
	(*obj).Enabled = enabled_value
	(*obj).InterfaceId = interfaceId_value
	(*obj).Addresses = addresses_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6Addresses, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	prefix_value := o.Prefix.ValueStringPointer()
	anycast_value := o.Anycast.ValueStringPointer()
	var advertise_entry *ethernet.Layer3Ipv6AddressesAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6AddressesAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6Addresses)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Prefix = prefix_value
	(*obj).Anycast = anycast_value
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6AddressesAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressesAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var routerAdvertisement_entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement
	if o.RouterAdvertisement != nil {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
		}

		diags.Append(o.RouterAdvertisement.CopyToPango(ctx, &routerAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	enableDad_value := o.EnableDad.ValueBoolPointer()
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscovery)
	}
	(*obj).RouterAdvertisement = routerAdvertisement_entry
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).EnableDad = enableDad_value
	(*obj).DadAttempts = dadAttempts_value
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
	}
	(*obj).OtherFlag = otherFlag_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).MinInterval = minInterval_value
	(*obj).Lifetime = lifetime_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).HopLimit = hopLimit_value
	(*obj).RouterPreference = routerPreference_value
	(*obj).Enable = enable_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).LinkMtu = linkMtu_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_entry *ethernet.Layer3Ipv6DnsServerSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6DnsServerSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSupport_entry *ethernet.Layer3Ipv6DnsServerDnsSupport
	if o.DnsSupport != nil {
		if *obj != nil && (*obj).DnsSupport != nil {
			dnsSupport_entry = (*obj).DnsSupport
		} else {
			dnsSupport_entry = new(ethernet.Layer3Ipv6DnsServerDnsSupport)
		}

		diags.Append(o.DnsSupport.CopyToPango(ctx, &dnsSupport_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServer)
	}
	(*obj).Source = source_entry
	(*obj).DnsSupport = dnsSupport_entry
	(*obj).Enable = enable_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6DnsServerSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6DnsServerSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6DnsServerSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6DnsServerSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6DnsServerSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6DnsServerSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject
	var server_pango_entries []ethernet.Layer3Ipv6DnsServerDnsSupportServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6DnsServerDnsSupportServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}
	var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6DnsServerDnsSupportSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6DnsServerDnsSupportSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerDnsSupport)
	}
	(*obj).Enable = enable_value
	(*obj).Server = server_pango_entries
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerDnsSupportServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject) CopyToPango(ctx context.Context, obj **ethernet.Layer3Ipv6DnsServerDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DnsServerDnsSupportSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceTapObject) CopyToPango(ctx context.Context, obj **ethernet.Tap, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Tap)
	}
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceResourceHaObject) CopyToPango(ctx context.Context, obj **ethernet.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Ha)
	}

	return diags
}

func (o *EthernetInterfaceResourceModel) CopyFromPango(ctx context.Context, obj *ethernet.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var poe_object *EthernetInterfaceResourcePoeObject
	if obj.Poe != nil {
		poe_object = new(EthernetInterfaceResourcePoeObject)

		diags.Append(poe_object.CopyFromPango(ctx, obj.Poe, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tap_object *EthernetInterfaceResourceTapObject
	if obj.Tap != nil {
		tap_object = new(EthernetInterfaceResourceTapObject)

		diags.Append(tap_object.CopyFromPango(ctx, obj.Tap, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_object *EthernetInterfaceResourceHaObject
	if obj.Ha != nil {
		ha_object = new(EthernetInterfaceResourceHaObject)

		diags.Append(ha_object.CopyFromPango(ctx, obj.Ha, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_object *EthernetInterfaceResourceLayer3Object
	if obj.Layer3 != nil {
		layer3_object = new(EthernetInterfaceResourceLayer3Object)

		diags.Append(layer3_object.CopyFromPango(ctx, obj.Layer3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var linkState_value types.String
	if obj.LinkState != nil {
		linkState_value = types.StringValue(*obj.LinkState)
	}
	var linkSpeed_value types.String
	if obj.LinkSpeed != nil {
		linkSpeed_value = types.StringValue(*obj.LinkSpeed)
	}
	var linkDuplex_value types.String
	if obj.LinkDuplex != nil {
		linkDuplex_value = types.StringValue(*obj.LinkDuplex)
	}
	o.Name = types.StringValue(obj.Name)
	o.Comment = comment_value
	o.LinkState = linkState_value
	o.LinkSpeed = linkSpeed_value
	o.LinkDuplex = linkDuplex_value
	o.Poe = poe_object
	o.Tap = tap_object
	o.Ha = ha_object
	o.Layer3 = layer3_object

	return diags
}

func (o *EthernetInterfaceResourcePoeObject) CopyFromPango(ctx context.Context, obj *ethernet.Poe, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var reservedPower_value types.Int64
	if obj.ReservedPower != nil {
		reservedPower_value = types.Int64Value(*obj.ReservedPower)
	}
	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.ReservedPower = reservedPower_value
	o.Enabled = enabled_value

	return diags
}

func (o *EthernetInterfaceResourceTapObject) CopyFromPango(ctx context.Context, obj *ethernet.Tap, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceResourceHaObject) CopyFromPango(ctx context.Context, obj *ethernet.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Object) CopyFromPango(ctx context.Context, obj *ethernet.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ips_list types.List
	{
		var ips_tf_entries []EthernetInterfaceResourceLayer3IpsObject
		for _, elt := range obj.Ips {
			var entry EthernetInterfaceResourceLayer3IpsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ips_tf_entries = append(ips_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ips")
		ips_list, list_diags = types.ListValueFrom(ctx, schemaType, ips_tf_entries)
		diags.Append(list_diags...)
	}
	var arp_list types.List
	{
		var arp_tf_entries []EthernetInterfaceResourceLayer3ArpObject
		for _, elt := range obj.Arp {
			var entry EthernetInterfaceResourceLayer3ArpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			arp_tf_entries = append(arp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("arp")
		arp_list, list_diags = types.ListValueFrom(ctx, schemaType, arp_tf_entries)
		diags.Append(list_diags...)
	}
	var ipv6_object *EthernetInterfaceResourceLayer3Ipv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(EthernetInterfaceResourceLayer3Ipv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_object *EthernetInterfaceResourceLayer3DhcpClientObject
	if obj.DhcpClient != nil {
		dhcpClient_object = new(EthernetInterfaceResourceLayer3DhcpClientObject)

		diags.Append(dhcpClient_object.CopyFromPango(ctx, obj.DhcpClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bonjour_object *EthernetInterfaceResourceLayer3BonjourObject
	if obj.Bonjour != nil {
		bonjour_object = new(EthernetInterfaceResourceLayer3BonjourObject)

		diags.Append(bonjour_object.CopyFromPango(ctx, obj.Bonjour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_object *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject
	if obj.SdwanLinkSettings != nil {
		sdwanLinkSettings_object = new(EthernetInterfaceResourceLayer3SdwanLinkSettingsObject)

		diags.Append(sdwanLinkSettings_object.CopyFromPango(ctx, obj.SdwanLinkSettings, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var adjustTcpMss_object *EthernetInterfaceResourceLayer3AdjustTcpMssObject
	if obj.AdjustTcpMss != nil {
		adjustTcpMss_object = new(EthernetInterfaceResourceLayer3AdjustTcpMssObject)

		diags.Append(adjustTcpMss_object.CopyFromPango(ctx, obj.AdjustTcpMss, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_object *EthernetInterfaceResourceLayer3LldpObject
	if obj.Lldp != nil {
		lldp_object = new(EthernetInterfaceResourceLayer3LldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceManagementProfile_value types.String
	if obj.InterfaceManagementProfile != nil {
		interfaceManagementProfile_value = types.StringValue(*obj.InterfaceManagementProfile)
	}
	var mtu_value types.Int64
	if obj.Mtu != nil {
		mtu_value = types.Int64Value(*obj.Mtu)
	}
	var untaggedSubInterface_value types.Bool
	if obj.UntaggedSubInterface != nil {
		untaggedSubInterface_value = types.BoolValue(*obj.UntaggedSubInterface)
	}
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	var ndpProxy_value types.Bool
	if obj.NdpProxy != nil {
		ndpProxy_value = types.BoolValue(*obj.NdpProxy)
	}
	o.Ips = ips_list
	o.Ipv6 = ipv6_object
	o.DhcpClient = dhcpClient_object
	o.InterfaceManagementProfile = interfaceManagementProfile_value
	o.Bonjour = bonjour_object
	o.SdwanLinkSettings = sdwanLinkSettings_object
	o.Arp = arp_list
	o.Mtu = mtu_value
	o.UntaggedSubInterface = untaggedSubInterface_value
	o.NetflowProfile = netflowProfile_value
	o.AdjustTcpMss = adjustTcpMss_object
	o.NdpProxy = ndpProxy_value
	o.Lldp = lldp_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3LldpObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv6MssAdjustment_value types.Int64
	if obj.Ipv6MssAdjustment != nil {
		ipv6MssAdjustment_value = types.Int64Value(*obj.Ipv6MssAdjustment)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var ipv4MssAdjustment_value types.Int64
	if obj.Ipv4MssAdjustment != nil {
		ipv4MssAdjustment_value = types.Int64Value(*obj.Ipv4MssAdjustment)
	}
	o.Ipv6MssAdjustment = ipv6MssAdjustment_value
	o.Enable = enable_value
	o.Ipv4MssAdjustment = ipv4MssAdjustment_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var upstreamNat_object *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject
	if obj.UpstreamNat != nil {
		upstreamNat_object = new(EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject)

		diags.Append(upstreamNat_object.CopyFromPango(ctx, obj.UpstreamNat, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var sdwanInterfaceProfile_value types.String
	if obj.SdwanInterfaceProfile != nil {
		sdwanInterfaceProfile_value = types.StringValue(*obj.SdwanInterfaceProfile)
	}
	o.Enable = enable_value
	o.SdwanInterfaceProfile = sdwanInterfaceProfile_value
	o.UpstreamNat = upstreamNat_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var staticIp_value types.String
	if obj.StaticIp != nil {
		staticIp_value = types.StringValue(*obj.StaticIp)
	}
	o.Enable = enable_value
	o.StaticIp = staticIp_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3ArpObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3IpsObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ips, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sdwanGateway_value types.String
	if obj.SdwanGateway != nil {
		sdwanGateway_value = types.StringValue(*obj.SdwanGateway)
	}
	o.Name = types.StringValue(obj.Name)
	o.SdwanGateway = sdwanGateway_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6Object) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_list types.List
	{
		var addresses_tf_entries []EthernetInterfaceResourceLayer3Ipv6AddressesObject
		for _, elt := range obj.Addresses {
			var entry EthernetInterfaceResourceLayer3Ipv6AddressesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addresses_tf_entries = append(addresses_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("addresses")
		addresses_list, list_diags = types.ListValueFrom(ctx, schemaType, addresses_tf_entries)
		diags.Append(list_diags...)
	}
	var neighborDiscovery_object *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsServer_object *EthernetInterfaceResourceLayer3Ipv6DnsServerObject
	if obj.DnsServer != nil {
		dnsServer_object = new(EthernetInterfaceResourceLayer3Ipv6DnsServerObject)

		diags.Append(dnsServer_object.CopyFromPango(ctx, obj.DnsServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	var interfaceId_value types.String
	if obj.InterfaceId != nil {
		interfaceId_value = types.StringValue(*obj.InterfaceId)
	}
	o.Enabled = enabled_value
	o.InterfaceId = interfaceId_value
	o.Addresses = addresses_list
	o.NeighborDiscovery = neighborDiscovery_object
	o.DnsServer = dnsServer_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6Addresses, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var prefix_value types.String
	if obj.Prefix != nil {
		prefix_value = types.StringValue(*obj.Prefix)
	}
	var anycast_value types.String
	if obj.Anycast != nil {
		anycast_value = types.StringValue(*obj.Anycast)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.EnableOnInterface = enableOnInterface_value
	o.Prefix = prefix_value
	o.Anycast = anycast_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6AddressesAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var routerAdvertisement_object *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	if obj.RouterAdvertisement != nil {
		routerAdvertisement_object = new(EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject)

		diags.Append(routerAdvertisement_object.CopyFromPango(ctx, obj.RouterAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.RouterAdvertisement = routerAdvertisement_object
	o.Neighbor = neighbor_list
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.EnableDad = enableDad_value
	o.DadAttempts = dadAttempts_value
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	o.MaxInterval = maxInterval_value
	o.LinkMtu = linkMtu_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.HopLimit = hopLimit_value
	o.RouterPreference = routerPreference_value
	o.Enable = enable_value
	o.Lifetime = lifetime_value
	o.ManagedFlag = managedFlag_value
	o.OtherFlag = otherFlag_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.MinInterval = minInterval_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject
	if obj.Source != nil {
		source_object = new(EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSupport_object *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject
	if obj.DnsSupport != nil {
		dnsSupport_object = new(EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject)

		diags.Append(dnsSupport_object.CopyFromPango(ctx, obj.DnsSupport, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Source = source_object
	o.DnsSupport = dnsSupport_object
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject
	if obj.Manual != nil {
		manual_object = new(EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject
		for _, elt := range obj.Suffix {
			var entry EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}
	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerSourceManualSuffixObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject
		for _, elt := range obj.Server {
			var entry EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject
		for _, elt := range obj.Suffix {
			var entry EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Server = server_list
	o.Suffix = suffix_list
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportServerObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DnsServerDnsSupportSuffixObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Ipv6DnsServerDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3DhcpClientObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sendHostname_object *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject
	if obj.SendHostname != nil {
		sendHostname_object = new(EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject)

		diags.Append(sendHostname_object.CopyFromPango(ctx, obj.SendHostname, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.SendHostname = sendHostname_object
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.Enable = enable_value
	o.Hostname = hostname_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3BonjourObject) CopyFromPango(ctx context.Context, obj *ethernet.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (r *EthernetInterfaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.
	loc := EthernetInterfaceResourceTfid{Name: state.Name.ValueString()}

	// TODO: this needs to handle location structure for UUID style shared has nested structure type

	if state.Location.TemplateStack != nil {
		loc.Location.TemplateStack = &ethernet.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Ngfw != nil {
		loc.Location.Ngfw = &ethernet.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		loc.Location.Template = &ethernet.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}

	if err := loc.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *ethernet.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	var location ethernet.ImportLocation

	if state.Location.Template != nil {
		// Vsys
		location = ethernet.NewLayer3TemplateVsysImportLocation(ethernet.Layer3TemplateVsysImportLocationSpec{
			Vsys: state.Location.Template.Vsys.ValueString(),
		})
	}

	created, err := r.manager.Create(ctx, loc.Location, []ethernet.ImportLocation{location}, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	// Tfid handling.
	tfid, err := EncodeLocation(&loc)
	if err != nil {
		resp.Diagnostics.AddError("Error creating tfid", err.Error())
		return
	}

	// Save the state.
	state.Tfid = types.StringValue(tfid)

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (o *EthernetInterfaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var loc EthernetInterfaceResourceTfid
	// Parse the location from tfid.
	if err := DecodeLocation(savestate.Tfid.ValueString(), &loc); err != nil {
		resp.Diagnostics.AddError("Error parsing tfid", err.Error())
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Read",
		"name":          loc.Name,
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, loc.Location, loc.Name)
	if err != nil {
		tflog.Warn(ctx, "KK: HERE3-1", map[string]any{"Error": err.Error()})
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location
	// Save tfid to state.
	state.Tfid = savestate.Tfid

	// Save the answer to state.

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *EthernetInterfaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var loc EthernetInterfaceResourceTfid
	if err := DecodeLocation(state.Tfid.ValueString(), &loc); err != nil {
		resp.Diagnostics.AddError("Error parsing tfid", err.Error())
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Update",
		"tfid":          state.Tfid.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, loc.Location, loc.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, loc.Location, obj, loc.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	// Save the tfid.
	loc.Name = obj.Name
	tfid, err := EncodeLocation(&loc)
	if err != nil {
		resp.Diagnostics.AddError("error creating tfid", err.Error())
		return
	}
	state.Tfid = types.StringValue(tfid)

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *EthernetInterfaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Parse the location from tfid.
	var loc EthernetInterfaceResourceTfid
	if err := DecodeLocation(state.Tfid.ValueString(), &loc); err != nil {
		resp.Diagnostics.AddError("error parsing tfid", err.Error())
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Delete",
		"name":          loc.Name,
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location ethernet.ImportLocation

	if state.Location.Template != nil {
		// Vsys
		location = ethernet.NewLayer3TemplateVsysImportLocation(ethernet.Layer3TemplateVsysImportLocationSpec{
			Vsys: state.Location.Template.Vsys.ValueString(),
		})
	}

	err := r.manager.Delete(ctx, loc.Location, []ethernet.ImportLocation{location}, []string{loc.Name}, sdkmanager.NonExhaustive)
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

func (r *EthernetInterfaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

type EthernetInterfaceTemplateLocation struct {
	Vsys           types.String `tfsdk:"vsys"`
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type EthernetInterfaceTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type EthernetInterfaceNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type EthernetInterfaceLocation struct {
	Template      *EthernetInterfaceTemplateLocation      `tfsdk:"template"`
	TemplateStack *EthernetInterfaceTemplateStackLocation `tfsdk:"template_stack"`
	Ngfw          *EthernetInterfaceNgfwLocation          `tfsdk:"ngfw"`
}

func EthernetInterfaceLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"vsys": rsschema.StringAttribute{
						Description: "",
						Required:    true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template stack.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}
